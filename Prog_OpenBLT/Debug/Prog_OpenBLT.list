
Prog_OpenBLT.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  0800a000  0800a000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .infoTable    0000000c  0800a200  0800a200  00001200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00002e50  0800a2c0  0800a2c0  000012c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000005c  0800d110  0800d110  00004110  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  0800d16c  0800d16c  0000500c  2**0
                  CONTENTS, READONLY
  5 .ARM          00000000  0800d16c  0800d16c  0000500c  2**0
                  CONTENTS, READONLY
  6 .preinit_array 00000000  0800d16c  0800d16c  0000500c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  0800d16c  0800d16c  0000416c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  0800d170  0800d170  00004170  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         0000000c  20000000  0800d174  00005000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .ccmram       00000000  10000000  10000000  0000500c  2**0
                  CONTENTS
 11 .bss          0000006c  2000000c  2000000c  0000500c  2**2
                  ALLOC
 12 ._user_heap_stack 00000600  20000078  20000078  0000500c  2**0
                  ALLOC
 13 .ARM.attributes 00000030  00000000  00000000  0000500c  2**0
                  CONTENTS, READONLY
 14 .debug_info   00007a30  00000000  00000000  0000503c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000197a  00000000  00000000  0000ca6c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00000660  00000000  00000000  0000e3e8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 0000049b  00000000  00000000  0000ea48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0001fadc  00000000  00000000  0000eee3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00009c37  00000000  00000000  0002e9bf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000beb22  00000000  00000000  000385f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  000f7118  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000016f0  00000000  00000000  000f715c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 0000005e  00000000  00000000  000f884c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800a2c0 <__do_global_dtors_aux>:
 800a2c0:	b510      	push	{r4, lr}
 800a2c2:	4c05      	ldr	r4, [pc, #20]	@ (800a2d8 <__do_global_dtors_aux+0x18>)
 800a2c4:	7823      	ldrb	r3, [r4, #0]
 800a2c6:	b933      	cbnz	r3, 800a2d6 <__do_global_dtors_aux+0x16>
 800a2c8:	4b04      	ldr	r3, [pc, #16]	@ (800a2dc <__do_global_dtors_aux+0x1c>)
 800a2ca:	b113      	cbz	r3, 800a2d2 <__do_global_dtors_aux+0x12>
 800a2cc:	4804      	ldr	r0, [pc, #16]	@ (800a2e0 <__do_global_dtors_aux+0x20>)
 800a2ce:	f3af 8000 	nop.w
 800a2d2:	2301      	movs	r3, #1
 800a2d4:	7023      	strb	r3, [r4, #0]
 800a2d6:	bd10      	pop	{r4, pc}
 800a2d8:	2000000c 	.word	0x2000000c
 800a2dc:	00000000 	.word	0x00000000
 800a2e0:	0800d0f8 	.word	0x0800d0f8

0800a2e4 <frame_dummy>:
 800a2e4:	b508      	push	{r3, lr}
 800a2e6:	4b03      	ldr	r3, [pc, #12]	@ (800a2f4 <frame_dummy+0x10>)
 800a2e8:	b11b      	cbz	r3, 800a2f2 <frame_dummy+0xe>
 800a2ea:	4903      	ldr	r1, [pc, #12]	@ (800a2f8 <frame_dummy+0x14>)
 800a2ec:	4803      	ldr	r0, [pc, #12]	@ (800a2fc <frame_dummy+0x18>)
 800a2ee:	f3af 8000 	nop.w
 800a2f2:	bd08      	pop	{r3, pc}
 800a2f4:	00000000 	.word	0x00000000
 800a2f8:	20000010 	.word	0x20000010
 800a2fc:	0800d0f8 	.word	0x0800d0f8

0800a300 <AppInit>:
**            software program initialization.
** \return    none.
**
****************************************************************************************/
void AppInit(void)
{
 800a300:	b580      	push	{r7, lr}
 800a302:	af00      	add	r7, sp, #0
  /* Initialize the timer driver. */
  TimerInit();
 800a304:	f000 f9a0 	bl	800a648 <TimerInit>
  /* Initialize the led driver. */
  LedInit();
 800a308:	f000 f962 	bl	800a5d0 <LedInit>
  /* initialize the bootloader interface */
  BootComInit();
 800a30c:	f000 f820 	bl	800a350 <BootComInit>
} /*** end of AppInit ***/
 800a310:	bf00      	nop
 800a312:	bd80      	pop	{r7, pc}

0800a314 <AppTask>:
**            continuously in the program loop.
** \return    none.
**
****************************************************************************************/
void AppTask(void)
{
 800a314:	b580      	push	{r7, lr}
 800a316:	af00      	add	r7, sp, #0
  /* Toggle LED with a fixed frequency. */
  LedToggle();
 800a318:	f000 f964 	bl	800a5e4 <LedToggle>
  /* check for bootloader activation request */
  BootComCheckActivationRequest();
 800a31c:	f000 f81e 	bl	800a35c <BootComCheckActivationRequest>
} /*** end of AppTask ***/
 800a320:	bf00      	nop
 800a322:	bd80      	pop	{r7, pc}

0800a324 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 800a324:	b480      	push	{r7}
 800a326:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800a328:	f3bf 8f4f 	dsb	sy
}
 800a32c:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800a32e:	4b06      	ldr	r3, [pc, #24]	@ (800a348 <__NVIC_SystemReset+0x24>)
 800a330:	68db      	ldr	r3, [r3, #12]
 800a332:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800a336:	4904      	ldr	r1, [pc, #16]	@ (800a348 <__NVIC_SystemReset+0x24>)
 800a338:	4b04      	ldr	r3, [pc, #16]	@ (800a34c <__NVIC_SystemReset+0x28>)
 800a33a:	4313      	orrs	r3, r2
 800a33c:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 800a33e:	f3bf 8f4f 	dsb	sy
}
 800a342:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800a344:	bf00      	nop
 800a346:	e7fd      	b.n	800a344 <__NVIC_SystemReset+0x20>
 800a348:	e000ed00 	.word	0xe000ed00
 800a34c:	05fa0004 	.word	0x05fa0004

0800a350 <BootComInit>:
** \brief     Initializes the communication interface.
** \return    none.
**
****************************************************************************************/
void BootComInit(void)
{
 800a350:	b580      	push	{r7, lr}
 800a352:	af00      	add	r7, sp, #0
#if (BOOT_COM_RS232_ENABLE > 0)
  BootComRs232Init();
#endif
#if (BOOT_COM_CAN_ENABLE > 0)
  BootComCanInit();
 800a354:	f000 f874 	bl	800a440 <BootComCanInit>
#endif
} /*** end of BootComInit ***/
 800a358:	bf00      	nop
 800a35a:	bd80      	pop	{r7, pc}

0800a35c <BootComCheckActivationRequest>:
**            bootloader should be activated and, if so, activates it.
** \return    none.
**
****************************************************************************************/
void BootComCheckActivationRequest(void)
{
 800a35c:	b580      	push	{r7, lr}
 800a35e:	af00      	add	r7, sp, #0
#if (BOOT_COM_RS232_ENABLE > 0)
  BootComRs232CheckActivationRequest();
#endif
#if (BOOT_COM_CAN_ENABLE > 0)
  BootComCanCheckActivationRequest();
 800a360:	f000 f8f4 	bl	800a54c <BootComCanCheckActivationRequest>
#endif
} /*** end of BootComCheckActivationRequest ***/
 800a364:	bf00      	nop
 800a366:	bd80      	pop	{r7, pc}

0800a368 <BootActivate>:
** \brief     Bootloader activation function.
** \return    none.
**
****************************************************************************************/
void BootActivate(void)
{
 800a368:	b580      	push	{r7, lr}
 800a36a:	af00      	add	r7, sp, #0
  /* perform software reset to activate the bootoader again */
  NVIC_SystemReset();
 800a36c:	f7ff ffda 	bl	800a324 <__NVIC_SystemReset>

0800a370 <CanGetSpeedConfig>:
** \return    1 if the CAN bustiming register values were found, 0 otherwise.
**
****************************************************************************************/
static unsigned char CanGetSpeedConfig(unsigned short baud, unsigned short *prescaler,
                                       unsigned char *tseg1, unsigned char *tseg2)
{
 800a370:	b580      	push	{r7, lr}
 800a372:	b086      	sub	sp, #24
 800a374:	af00      	add	r7, sp, #0
 800a376:	60b9      	str	r1, [r7, #8]
 800a378:	607a      	str	r2, [r7, #4]
 800a37a:	603b      	str	r3, [r7, #0]
 800a37c:	4603      	mov	r3, r0
 800a37e:	81fb      	strh	r3, [r7, #14]
  unsigned char cnt;
  unsigned long canClockFreqkHz;

  /* store CAN peripheral clock speed in kHz */
  canClockFreqkHz = HAL_RCC_GetPCLK1Freq() / 1000u;
 800a380:	f002 fc50 	bl	800cc24 <HAL_RCC_GetPCLK1Freq>
 800a384:	4603      	mov	r3, r0
 800a386:	4a2c      	ldr	r2, [pc, #176]	@ (800a438 <CanGetSpeedConfig+0xc8>)
 800a388:	fba2 2303 	umull	r2, r3, r2, r3
 800a38c:	099b      	lsrs	r3, r3, #6
 800a38e:	613b      	str	r3, [r7, #16]

  /* loop through all possible time quanta configurations to find a match */
  for (cnt=0; cnt < sizeof(canTiming)/sizeof(canTiming[0]); cnt++)
 800a390:	2300      	movs	r3, #0
 800a392:	75fb      	strb	r3, [r7, #23]
 800a394:	e048      	b.n	800a428 <CanGetSpeedConfig+0xb8>
  {
    if ((canClockFreqkHz % (baud*(canTiming[cnt].tseg1+canTiming[cnt].tseg2+1))) == 0)
 800a396:	89fa      	ldrh	r2, [r7, #14]
 800a398:	7dfb      	ldrb	r3, [r7, #23]
 800a39a:	4928      	ldr	r1, [pc, #160]	@ (800a43c <CanGetSpeedConfig+0xcc>)
 800a39c:	f811 3013 	ldrb.w	r3, [r1, r3, lsl #1]
 800a3a0:	4618      	mov	r0, r3
 800a3a2:	7dfb      	ldrb	r3, [r7, #23]
 800a3a4:	4925      	ldr	r1, [pc, #148]	@ (800a43c <CanGetSpeedConfig+0xcc>)
 800a3a6:	005b      	lsls	r3, r3, #1
 800a3a8:	440b      	add	r3, r1
 800a3aa:	785b      	ldrb	r3, [r3, #1]
 800a3ac:	4403      	add	r3, r0
 800a3ae:	3301      	adds	r3, #1
 800a3b0:	fb02 f303 	mul.w	r3, r2, r3
 800a3b4:	461a      	mov	r2, r3
 800a3b6:	693b      	ldr	r3, [r7, #16]
 800a3b8:	fbb3 f1f2 	udiv	r1, r3, r2
 800a3bc:	fb01 f202 	mul.w	r2, r1, r2
 800a3c0:	1a9b      	subs	r3, r3, r2
 800a3c2:	2b00      	cmp	r3, #0
 800a3c4:	d12d      	bne.n	800a422 <CanGetSpeedConfig+0xb2>
    {
      /* compute the prescaler that goes with this TQ configuration */
      *prescaler = canClockFreqkHz/(baud*(canTiming[cnt].tseg1+canTiming[cnt].tseg2+1));
 800a3c6:	89fa      	ldrh	r2, [r7, #14]
 800a3c8:	7dfb      	ldrb	r3, [r7, #23]
 800a3ca:	491c      	ldr	r1, [pc, #112]	@ (800a43c <CanGetSpeedConfig+0xcc>)
 800a3cc:	f811 3013 	ldrb.w	r3, [r1, r3, lsl #1]
 800a3d0:	4618      	mov	r0, r3
 800a3d2:	7dfb      	ldrb	r3, [r7, #23]
 800a3d4:	4919      	ldr	r1, [pc, #100]	@ (800a43c <CanGetSpeedConfig+0xcc>)
 800a3d6:	005b      	lsls	r3, r3, #1
 800a3d8:	440b      	add	r3, r1
 800a3da:	785b      	ldrb	r3, [r3, #1]
 800a3dc:	4403      	add	r3, r0
 800a3de:	3301      	adds	r3, #1
 800a3e0:	fb02 f303 	mul.w	r3, r2, r3
 800a3e4:	461a      	mov	r2, r3
 800a3e6:	693b      	ldr	r3, [r7, #16]
 800a3e8:	fbb3 f3f2 	udiv	r3, r3, r2
 800a3ec:	b29a      	uxth	r2, r3
 800a3ee:	68bb      	ldr	r3, [r7, #8]
 800a3f0:	801a      	strh	r2, [r3, #0]

      /* make sure the prescaler is valid */
      if ( (*prescaler > 0) && (*prescaler <= 1024) )
 800a3f2:	68bb      	ldr	r3, [r7, #8]
 800a3f4:	881b      	ldrh	r3, [r3, #0]
 800a3f6:	2b00      	cmp	r3, #0
 800a3f8:	d013      	beq.n	800a422 <CanGetSpeedConfig+0xb2>
 800a3fa:	68bb      	ldr	r3, [r7, #8]
 800a3fc:	881b      	ldrh	r3, [r3, #0]
 800a3fe:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800a402:	d80e      	bhi.n	800a422 <CanGetSpeedConfig+0xb2>
      {
        /* store the bustiming configuration */
        *tseg1 = canTiming[cnt].tseg1;
 800a404:	7dfb      	ldrb	r3, [r7, #23]
 800a406:	4a0d      	ldr	r2, [pc, #52]	@ (800a43c <CanGetSpeedConfig+0xcc>)
 800a408:	f812 2013 	ldrb.w	r2, [r2, r3, lsl #1]
 800a40c:	687b      	ldr	r3, [r7, #4]
 800a40e:	701a      	strb	r2, [r3, #0]
        *tseg2 = canTiming[cnt].tseg2;
 800a410:	7dfb      	ldrb	r3, [r7, #23]
 800a412:	4a0a      	ldr	r2, [pc, #40]	@ (800a43c <CanGetSpeedConfig+0xcc>)
 800a414:	005b      	lsls	r3, r3, #1
 800a416:	4413      	add	r3, r2
 800a418:	785a      	ldrb	r2, [r3, #1]
 800a41a:	683b      	ldr	r3, [r7, #0]
 800a41c:	701a      	strb	r2, [r3, #0]
        /* found a good bus timing configuration */
        return 1;
 800a41e:	2301      	movs	r3, #1
 800a420:	e006      	b.n	800a430 <CanGetSpeedConfig+0xc0>
  for (cnt=0; cnt < sizeof(canTiming)/sizeof(canTiming[0]); cnt++)
 800a422:	7dfb      	ldrb	r3, [r7, #23]
 800a424:	3301      	adds	r3, #1
 800a426:	75fb      	strb	r3, [r7, #23]
 800a428:	7dfb      	ldrb	r3, [r7, #23]
 800a42a:	2b11      	cmp	r3, #17
 800a42c:	d9b3      	bls.n	800a396 <CanGetSpeedConfig+0x26>
      }
    }
  }
  /* could not find a good bus timing configuration */
  return 0;
 800a42e:	2300      	movs	r3, #0
} /*** end of CanGetSpeedConfig ***/
 800a430:	4618      	mov	r0, r3
 800a432:	3718      	adds	r7, #24
 800a434:	46bd      	mov	sp, r7
 800a436:	bd80      	pop	{r7, pc}
 800a438:	10624dd3 	.word	0x10624dd3
 800a43c:	0800d110 	.word	0x0800d110

0800a440 <BootComCanInit>:
** \brief     Initializes the CAN communication interface.
** \return    none.
**
****************************************************************************************/
static void BootComCanInit(void)
{
 800a440:	b580      	push	{r7, lr}
 800a442:	b08e      	sub	sp, #56	@ 0x38
 800a444:	af00      	add	r7, sp, #0
  unsigned short prescaler = 0;
 800a446:	2300      	movs	r3, #0
 800a448:	857b      	strh	r3, [r7, #42]	@ 0x2a
  unsigned char tseg1 = 0, tseg2 = 0;
 800a44a:	2300      	movs	r3, #0
 800a44c:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
 800a450:	2300      	movs	r3, #0
 800a452:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
  CAN_FilterTypeDef filterConfig;
  unsigned long rxMsgId = BOOT_COM_CAN_RX_MSG_ID;
 800a456:	f240 6367 	movw	r3, #1639	@ 0x667
 800a45a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  unsigned long rxFilterId, rxFilterMask;

  /* obtain bittiming configuration information. */
  CanGetSpeedConfig(BOOT_COM_CAN_BAUDRATE/1000, &prescaler, &tseg1, &tseg2);
 800a45c:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 800a460:	f107 0229 	add.w	r2, r7, #41	@ 0x29
 800a464:	f107 012a 	add.w	r1, r7, #42	@ 0x2a
 800a468:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 800a46c:	f7ff ff80 	bl	800a370 <CanGetSpeedConfig>

  /* set the CAN controller configuration. */
  canHandle.Instance = CAN;
 800a470:	4b32      	ldr	r3, [pc, #200]	@ (800a53c <BootComCanInit+0xfc>)
 800a472:	4a33      	ldr	r2, [pc, #204]	@ (800a540 <BootComCanInit+0x100>)
 800a474:	601a      	str	r2, [r3, #0]
  canHandle.Init.TimeTriggeredMode = DISABLE;
 800a476:	4b31      	ldr	r3, [pc, #196]	@ (800a53c <BootComCanInit+0xfc>)
 800a478:	2200      	movs	r2, #0
 800a47a:	761a      	strb	r2, [r3, #24]
  canHandle.Init.AutoBusOff = DISABLE;
 800a47c:	4b2f      	ldr	r3, [pc, #188]	@ (800a53c <BootComCanInit+0xfc>)
 800a47e:	2200      	movs	r2, #0
 800a480:	765a      	strb	r2, [r3, #25]
  canHandle.Init.AutoWakeUp = DISABLE;
 800a482:	4b2e      	ldr	r3, [pc, #184]	@ (800a53c <BootComCanInit+0xfc>)
 800a484:	2200      	movs	r2, #0
 800a486:	769a      	strb	r2, [r3, #26]
  canHandle.Init.AutoRetransmission = ENABLE;
 800a488:	4b2c      	ldr	r3, [pc, #176]	@ (800a53c <BootComCanInit+0xfc>)
 800a48a:	2201      	movs	r2, #1
 800a48c:	76da      	strb	r2, [r3, #27]
  canHandle.Init.ReceiveFifoLocked = DISABLE;
 800a48e:	4b2b      	ldr	r3, [pc, #172]	@ (800a53c <BootComCanInit+0xfc>)
 800a490:	2200      	movs	r2, #0
 800a492:	771a      	strb	r2, [r3, #28]
  canHandle.Init.TransmitFifoPriority = DISABLE;
 800a494:	4b29      	ldr	r3, [pc, #164]	@ (800a53c <BootComCanInit+0xfc>)
 800a496:	2200      	movs	r2, #0
 800a498:	775a      	strb	r2, [r3, #29]
  canHandle.Init.Mode = CAN_MODE_NORMAL;
 800a49a:	4b28      	ldr	r3, [pc, #160]	@ (800a53c <BootComCanInit+0xfc>)
 800a49c:	2200      	movs	r2, #0
 800a49e:	609a      	str	r2, [r3, #8]
  canHandle.Init.SyncJumpWidth = CAN_SJW_1TQ;
 800a4a0:	4b26      	ldr	r3, [pc, #152]	@ (800a53c <BootComCanInit+0xfc>)
 800a4a2:	2200      	movs	r2, #0
 800a4a4:	60da      	str	r2, [r3, #12]
  canHandle.Init.TimeSeg1 = ((unsigned long)tseg1 - 1) << CAN_BTR_TS1_Pos;
 800a4a6:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 800a4aa:	3b01      	subs	r3, #1
 800a4ac:	041b      	lsls	r3, r3, #16
 800a4ae:	4a23      	ldr	r2, [pc, #140]	@ (800a53c <BootComCanInit+0xfc>)
 800a4b0:	6113      	str	r3, [r2, #16]
  canHandle.Init.TimeSeg2 = ((unsigned long)tseg2 - 1) << CAN_BTR_TS2_Pos;
 800a4b2:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 800a4b6:	3b01      	subs	r3, #1
 800a4b8:	051b      	lsls	r3, r3, #20
 800a4ba:	4a20      	ldr	r2, [pc, #128]	@ (800a53c <BootComCanInit+0xfc>)
 800a4bc:	6153      	str	r3, [r2, #20]
  canHandle.Init.Prescaler = prescaler;
 800a4be:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 800a4c0:	461a      	mov	r2, r3
 800a4c2:	4b1e      	ldr	r3, [pc, #120]	@ (800a53c <BootComCanInit+0xfc>)
 800a4c4:	605a      	str	r2, [r3, #4]
  /* initialize the CAN controller. this only fails if the CAN controller hardware is
   * faulty. no need to evaluate the return value as there is nothing we can do about
   * a faulty CAN controller.
   */
  (void)HAL_CAN_Init(&canHandle);
 800a4c6:	481d      	ldr	r0, [pc, #116]	@ (800a53c <BootComCanInit+0xfc>)
 800a4c8:	f000 fb36 	bl	800ab38 <HAL_CAN_Init>
  /* determine the reception filter mask and id values such that it only leaves one
   * CAN identifier through (BOOT_COM_CAN_RX_MSG_ID).
   */
  if ((rxMsgId & 0x80000000) == 0)
 800a4cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a4ce:	2b00      	cmp	r3, #0
 800a4d0:	db05      	blt.n	800a4de <BootComCanInit+0x9e>
  {
    rxFilterId = rxMsgId << CAN_RI0R_STID_Pos;
 800a4d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a4d4:	055b      	lsls	r3, r3, #21
 800a4d6:	637b      	str	r3, [r7, #52]	@ 0x34
    rxFilterMask = (CAN_RI0R_STID_Msk) | CAN_RI0R_IDE;
 800a4d8:	4b1a      	ldr	r3, [pc, #104]	@ (800a544 <BootComCanInit+0x104>)
 800a4da:	633b      	str	r3, [r7, #48]	@ 0x30
 800a4dc:	e00a      	b.n	800a4f4 <BootComCanInit+0xb4>
  }
  else
  {
    /* negate the ID-type bit */
    rxMsgId &= ~0x80000000;
 800a4de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a4e0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800a4e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    rxFilterId = (rxMsgId << CAN_RI0R_EXID_Pos) | CAN_RI0R_IDE;
 800a4e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800a4e8:	00db      	lsls	r3, r3, #3
 800a4ea:	f043 0304 	orr.w	r3, r3, #4
 800a4ee:	637b      	str	r3, [r7, #52]	@ 0x34
    rxFilterMask = (CAN_RI0R_EXID_Msk) | CAN_RI0R_IDE;
 800a4f0:	4b15      	ldr	r3, [pc, #84]	@ (800a548 <BootComCanInit+0x108>)
 800a4f2:	633b      	str	r3, [r7, #48]	@ 0x30
  }
  /* configure the reception filter. note that the implementation of this function
   * always returns HAL_OK, so no need to evaluate the return value.
   */
  filterConfig.FilterBank = 0;
 800a4f4:	2300      	movs	r3, #0
 800a4f6:	617b      	str	r3, [r7, #20]
  filterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
 800a4f8:	2300      	movs	r3, #0
 800a4fa:	61bb      	str	r3, [r7, #24]
  filterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
 800a4fc:	2301      	movs	r3, #1
 800a4fe:	61fb      	str	r3, [r7, #28]
  filterConfig.FilterIdHigh = (rxFilterId >> 16) & 0x0000FFFFu;
 800a500:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a502:	0c1b      	lsrs	r3, r3, #16
 800a504:	603b      	str	r3, [r7, #0]
  filterConfig.FilterIdLow = rxFilterId & 0x0000FFFFu;
 800a506:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a508:	b29b      	uxth	r3, r3
 800a50a:	607b      	str	r3, [r7, #4]
  filterConfig.FilterMaskIdHigh = (rxFilterMask >> 16) & 0x0000FFFFu;
 800a50c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a50e:	0c1b      	lsrs	r3, r3, #16
 800a510:	60bb      	str	r3, [r7, #8]
  filterConfig.FilterMaskIdLow = rxFilterMask & 0x0000FFFFu;
 800a512:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a514:	b29b      	uxth	r3, r3
 800a516:	60fb      	str	r3, [r7, #12]
  filterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
 800a518:	2300      	movs	r3, #0
 800a51a:	613b      	str	r3, [r7, #16]
  filterConfig.FilterActivation = ENABLE;
 800a51c:	2301      	movs	r3, #1
 800a51e:	623b      	str	r3, [r7, #32]
  filterConfig.SlaveStartFilterBank = 14;
 800a520:	230e      	movs	r3, #14
 800a522:	627b      	str	r3, [r7, #36]	@ 0x24
  (void)HAL_CAN_ConfigFilter(&canHandle, &filterConfig);
 800a524:	463b      	mov	r3, r7
 800a526:	4619      	mov	r1, r3
 800a528:	4804      	ldr	r0, [pc, #16]	@ (800a53c <BootComCanInit+0xfc>)
 800a52a:	f000 fc00 	bl	800ad2e <HAL_CAN_ConfigFilter>
  /* start the CAN peripheral. no need to evaluate the return value as there is nothing
   * we can do about a faulty CAN controller. */
  (void)HAL_CAN_Start(&canHandle);
 800a52e:	4803      	ldr	r0, [pc, #12]	@ (800a53c <BootComCanInit+0xfc>)
 800a530:	f000 fcc7 	bl	800aec2 <HAL_CAN_Start>
} /*** end of BootComCanInit ***/
 800a534:	bf00      	nop
 800a536:	3738      	adds	r7, #56	@ 0x38
 800a538:	46bd      	mov	sp, r7
 800a53a:	bd80      	pop	{r7, pc}
 800a53c:	20000028 	.word	0x20000028
 800a540:	40006400 	.word	0x40006400
 800a544:	ffe00004 	.word	0xffe00004
 800a548:	001ffffc 	.word	0x001ffffc

0800a54c <BootComCanCheckActivationRequest>:
**            bootloader should be activated and, if so, activates it.
** \return    none.
**
****************************************************************************************/
static void BootComCanCheckActivationRequest(void)
{
 800a54c:	b580      	push	{r7, lr}
 800a54e:	b08c      	sub	sp, #48	@ 0x30
 800a550:	af00      	add	r7, sp, #0
  unsigned long rxMsgId = BOOT_COM_CAN_RX_MSG_ID;
 800a552:	f240 6367 	movw	r3, #1639	@ 0x667
 800a556:	62bb      	str	r3, [r7, #40]	@ 0x28
  unsigned char packetIdMatches = 0;
 800a558:	2300      	movs	r3, #0
 800a55a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  CAN_RxHeaderTypeDef rxMsgHeader;
  unsigned char rxMsgData[8];

  /* poll for received CAN messages that await processing. */
  if (HAL_CAN_GetRxMessage(&canHandle, CAN_RX_FIFO0, &rxMsgHeader, rxMsgData) == HAL_OK)
 800a55e:	1d3b      	adds	r3, r7, #4
 800a560:	f107 020c 	add.w	r2, r7, #12
 800a564:	2100      	movs	r1, #0
 800a566:	4819      	ldr	r0, [pc, #100]	@ (800a5cc <BootComCanCheckActivationRequest+0x80>)
 800a568:	f000 fdbf 	bl	800b0ea <HAL_CAN_GetRxMessage>
 800a56c:	4603      	mov	r3, r0
 800a56e:	2b00      	cmp	r3, #0
 800a570:	d127      	bne.n	800a5c2 <BootComCanCheckActivationRequest+0x76>
  {
    /* check if this message has the configured CAN packet identifier. */
    if ((rxMsgId & 0x80000000) == 0)
 800a572:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a574:	2b00      	cmp	r3, #0
 800a576:	db0a      	blt.n	800a58e <BootComCanCheckActivationRequest+0x42>
    {
      /* was an 11-bit CAN message received that matches? */
      if ( (rxMsgHeader.StdId == rxMsgId) &&
 800a578:	68fb      	ldr	r3, [r7, #12]
 800a57a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a57c:	429a      	cmp	r2, r3
 800a57e:	d114      	bne.n	800a5aa <BootComCanCheckActivationRequest+0x5e>
           (rxMsgHeader.IDE == CAN_ID_STD) )
 800a580:	697b      	ldr	r3, [r7, #20]
      if ( (rxMsgHeader.StdId == rxMsgId) &&
 800a582:	2b00      	cmp	r3, #0
 800a584:	d111      	bne.n	800a5aa <BootComCanCheckActivationRequest+0x5e>
      {
        /* set flag that a packet with a matching CAN identifier was received. */
        packetIdMatches = 1;
 800a586:	2301      	movs	r3, #1
 800a588:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 800a58c:	e00d      	b.n	800a5aa <BootComCanCheckActivationRequest+0x5e>
      }
    }
    else
    {
      /* negate the ID-type bit */
      rxMsgId &= ~0x80000000;
 800a58e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a590:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800a594:	62bb      	str	r3, [r7, #40]	@ 0x28
      /* was an 29-bit CAN message received that matches? */
      if ( (rxMsgHeader.ExtId == rxMsgId) &&
 800a596:	693b      	ldr	r3, [r7, #16]
 800a598:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800a59a:	429a      	cmp	r2, r3
 800a59c:	d105      	bne.n	800a5aa <BootComCanCheckActivationRequest+0x5e>
           (rxMsgHeader.IDE == CAN_ID_EXT) )
 800a59e:	697b      	ldr	r3, [r7, #20]
      if ( (rxMsgHeader.ExtId == rxMsgId) &&
 800a5a0:	2b04      	cmp	r3, #4
 800a5a2:	d102      	bne.n	800a5aa <BootComCanCheckActivationRequest+0x5e>
      {
        /* set flag that a packet with a matching CAN identifier was received. */
        packetIdMatches = 1;
 800a5a4:	2301      	movs	r3, #1
 800a5a6:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
      }
    }

    /* only continue if a packet with a matching CAN identifier was received. */
    if (packetIdMatches == 1)
 800a5aa:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800a5ae:	2b01      	cmp	r3, #1
 800a5b0:	d107      	bne.n	800a5c2 <BootComCanCheckActivationRequest+0x76>
    {
      /* check if this was an XCP CONNECT command */
      if ((rxMsgData[0] == 0xff) && (rxMsgHeader.DLC == 2))
 800a5b2:	793b      	ldrb	r3, [r7, #4]
 800a5b4:	2bff      	cmp	r3, #255	@ 0xff
 800a5b6:	d104      	bne.n	800a5c2 <BootComCanCheckActivationRequest+0x76>
 800a5b8:	69fb      	ldr	r3, [r7, #28]
 800a5ba:	2b02      	cmp	r3, #2
 800a5bc:	d101      	bne.n	800a5c2 <BootComCanCheckActivationRequest+0x76>
      {
        /* connection request received so start the bootloader */
        BootActivate();
 800a5be:	f7ff fed3 	bl	800a368 <BootActivate>
      }
    }
  }
} /*** end of BootComCanCheckActivationRequest ***/
 800a5c2:	bf00      	nop
 800a5c4:	3730      	adds	r7, #48	@ 0x30
 800a5c6:	46bd      	mov	sp, r7
 800a5c8:	bd80      	pop	{r7, pc}
 800a5ca:	bf00      	nop
 800a5cc:	20000028 	.word	0x20000028

0800a5d0 <LedInit>:
** \brief     Initializes the LED. 
** \return    none.
**
****************************************************************************************/
void LedInit(void)
{
 800a5d0:	b580      	push	{r7, lr}
 800a5d2:	af00      	add	r7, sp, #0
  /* Note that the initialization of the LED GPIO pin is done in HAL_MspInit(). All that
   * is left to do here is to make sure the LED is turned off after initialization.
   */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
 800a5d4:	2200      	movs	r2, #0
 800a5d6:	2120      	movs	r1, #32
 800a5d8:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800a5dc:	f001 f918 	bl	800b810 <HAL_GPIO_WritePin>
} /*** end of LedInit ***/
 800a5e0:	bf00      	nop
 800a5e2:	bd80      	pop	{r7, pc}

0800a5e4 <LedToggle>:
** \brief     Toggles the LED at a fixed time interval.
** \return    none.
**
****************************************************************************************/
void LedToggle(void)
{
 800a5e4:	b580      	push	{r7, lr}
 800a5e6:	b082      	sub	sp, #8
 800a5e8:	af00      	add	r7, sp, #0
  static unsigned char led_toggle_state = 0;
  static unsigned long timer_counter_last = 0;
  unsigned long timer_counter_now;

  /* check if toggle interval time passed */
  timer_counter_now = TimerGet();
 800a5ea:	f000 f834 	bl	800a656 <TimerGet>
 800a5ee:	6078      	str	r0, [r7, #4]
  if ( (timer_counter_now - timer_counter_last) < LED_TOGGLE_MS)
 800a5f0:	4b13      	ldr	r3, [pc, #76]	@ (800a640 <LedToggle+0x5c>)
 800a5f2:	681b      	ldr	r3, [r3, #0]
 800a5f4:	687a      	ldr	r2, [r7, #4]
 800a5f6:	1ad3      	subs	r3, r2, r3
 800a5f8:	f240 52db 	movw	r2, #1499	@ 0x5db
 800a5fc:	4293      	cmp	r3, r2
 800a5fe:	d91a      	bls.n	800a636 <LedToggle+0x52>
    /* not yet time to toggle */
    return;
  }

  /* determine toggle action */
  if (led_toggle_state == 0)
 800a600:	4b10      	ldr	r3, [pc, #64]	@ (800a644 <LedToggle+0x60>)
 800a602:	781b      	ldrb	r3, [r3, #0]
 800a604:	2b00      	cmp	r3, #0
 800a606:	d109      	bne.n	800a61c <LedToggle+0x38>
  {
    led_toggle_state = 1;
 800a608:	4b0e      	ldr	r3, [pc, #56]	@ (800a644 <LedToggle+0x60>)
 800a60a:	2201      	movs	r2, #1
 800a60c:	701a      	strb	r2, [r3, #0]
    /* turn the LED on */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
 800a60e:	2201      	movs	r2, #1
 800a610:	2120      	movs	r1, #32
 800a612:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800a616:	f001 f8fb 	bl	800b810 <HAL_GPIO_WritePin>
 800a61a:	e008      	b.n	800a62e <LedToggle+0x4a>
  }
  else
  {
    led_toggle_state = 0;
 800a61c:	4b09      	ldr	r3, [pc, #36]	@ (800a644 <LedToggle+0x60>)
 800a61e:	2200      	movs	r2, #0
 800a620:	701a      	strb	r2, [r3, #0]
    /* turn the LED off */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
 800a622:	2200      	movs	r2, #0
 800a624:	2120      	movs	r1, #32
 800a626:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800a62a:	f001 f8f1 	bl	800b810 <HAL_GPIO_WritePin>
  }

  /* store toggle time to determine next toggle interval */
  timer_counter_last = timer_counter_now;
 800a62e:	4a04      	ldr	r2, [pc, #16]	@ (800a640 <LedToggle+0x5c>)
 800a630:	687b      	ldr	r3, [r7, #4]
 800a632:	6013      	str	r3, [r2, #0]
 800a634:	e000      	b.n	800a638 <LedToggle+0x54>
    return;
 800a636:	bf00      	nop
} /*** end of LedToggle ***/
 800a638:	3708      	adds	r7, #8
 800a63a:	46bd      	mov	sp, r7
 800a63c:	bd80      	pop	{r7, pc}
 800a63e:	bf00      	nop
 800a640:	20000050 	.word	0x20000050
 800a644:	20000054 	.word	0x20000054

0800a648 <TimerInit>:
** \brief     Initializes the timer.
** \return    none.
**
****************************************************************************************/
void TimerInit(void)
{
 800a648:	b480      	push	{r7}
 800a64a:	af00      	add	r7, sp, #0
  /* The HAL initialization already configured the Systick interrupt to generate an
   * interrupt every 1 millisecond. Nothing more needs to be done here.
   */
} /*** end of TimerInit ***/
 800a64c:	bf00      	nop
 800a64e:	46bd      	mov	sp, r7
 800a650:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a654:	4770      	bx	lr

0800a656 <TimerGet>:
** \brief     Obtains the counter value of the millisecond timer.
** \return    Current value of the millisecond timer.
**
****************************************************************************************/
unsigned long TimerGet(void)
{
 800a656:	b580      	push	{r7, lr}
 800a658:	af00      	add	r7, sp, #0
  /* Read and return the tick counter value. */
  return HAL_GetTick();
 800a65a:	f000 fa61 	bl	800ab20 <HAL_GetTick>
 800a65e:	4603      	mov	r3, r0
} /*** end of TimerGet ***/
 800a660:	4618      	mov	r0, r3
 800a662:	bd80      	pop	{r7, pc}

0800a664 <VectorBase_Config>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
static void VectorBase_Config(void)
{
 800a664:	b480      	push	{r7}
 800a666:	af00      	add	r7, sp, #0
   * c-startup code.
   */
  extern const unsigned long g_pfnVectors[];

  /* Remap the vector table to where the vector table is located for this program. */
  SCB->VTOR = (unsigned long)&g_pfnVectors[0];
 800a668:	4b03      	ldr	r3, [pc, #12]	@ (800a678 <VectorBase_Config+0x14>)
 800a66a:	4a04      	ldr	r2, [pc, #16]	@ (800a67c <VectorBase_Config+0x18>)
 800a66c:	609a      	str	r2, [r3, #8]
}
 800a66e:	bf00      	nop
 800a670:	46bd      	mov	sp, r7
 800a672:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a676:	4770      	bx	lr
 800a678:	e000ed00 	.word	0xe000ed00
 800a67c:	0800a000 	.word	0x0800a000

0800a680 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800a680:	b580      	push	{r7, lr}
 800a682:	b086      	sub	sp, #24
 800a684:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN 1 */
  VectorBase_Config();
 800a686:	f7ff ffed 	bl	800a664 <VectorBase_Config>
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800a68a:	f000 f9ef 	bl	800aa6c <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800a68e:	f000 f851 	bl	800a734 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800a692:	f000 f8ad 	bl	800a7f0 <MX_GPIO_Init>
  /* USER CODE BEGIN 2 */
  AppInit();
 800a696:	f7ff fe33 	bl	800a300 <AppInit>
  HAL_CAN_Start(&canHandle);
 800a69a:	4823      	ldr	r0, [pc, #140]	@ (800a728 <main+0xa8>)
 800a69c:	f000 fc11 	bl	800aec2 <HAL_CAN_Start>
  Txheader.StdId = 0x150;
 800a6a0:	4b22      	ldr	r3, [pc, #136]	@ (800a72c <main+0xac>)
 800a6a2:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 800a6a6:	601a      	str	r2, [r3, #0]
  Txheader.IDE = CAN_ID_STD;
 800a6a8:	4b20      	ldr	r3, [pc, #128]	@ (800a72c <main+0xac>)
 800a6aa:	2200      	movs	r2, #0
 800a6ac:	609a      	str	r2, [r3, #8]
  Txheader.RTR = CAN_RTR_DATA;
 800a6ae:	4b1f      	ldr	r3, [pc, #124]	@ (800a72c <main+0xac>)
 800a6b0:	2200      	movs	r2, #0
 800a6b2:	60da      	str	r2, [r3, #12]
  Txheader.DLC = 8;
 800a6b4:	4b1d      	ldr	r3, [pc, #116]	@ (800a72c <main+0xac>)
 800a6b6:	2208      	movs	r2, #8
 800a6b8:	611a      	str	r2, [r3, #16]

  uint8_t data[8];
  for (int i =0; i<7; i++){
 800a6ba:	2300      	movs	r3, #0
 800a6bc:	617b      	str	r3, [r7, #20]
 800a6be:	e007      	b.n	800a6d0 <main+0x50>
	  data[i] =0;
 800a6c0:	463a      	mov	r2, r7
 800a6c2:	697b      	ldr	r3, [r7, #20]
 800a6c4:	4413      	add	r3, r2
 800a6c6:	2200      	movs	r2, #0
 800a6c8:	701a      	strb	r2, [r3, #0]
  for (int i =0; i<7; i++){
 800a6ca:	697b      	ldr	r3, [r7, #20]
 800a6cc:	3301      	adds	r3, #1
 800a6ce:	617b      	str	r3, [r7, #20]
 800a6d0:	697b      	ldr	r3, [r7, #20]
 800a6d2:	2b06      	cmp	r3, #6
 800a6d4:	ddf4      	ble.n	800a6c0 <main+0x40>
  }
  //data[0] = 0;
 // data[1] = 0;
  unsigned long counter_now =0;
 800a6d6:	2300      	movs	r3, #0
 800a6d8:	60fb      	str	r3, [r7, #12]
  unsigned long counter_last = 0;
 800a6da:	2300      	movs	r3, #0
 800a6dc:	613b      	str	r3, [r7, #16]
  unsigned long transmit_duration = 100;
 800a6de:	2364      	movs	r3, #100	@ 0x64
 800a6e0:	60bb      	str	r3, [r7, #8]

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
  AppTask();
 800a6e2:	f7ff fe17 	bl	800a314 <AppTask>
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  counter_now = TimerGet();
 800a6e6:	f7ff ffb6 	bl	800a656 <TimerGet>
 800a6ea:	60f8      	str	r0, [r7, #12]
  if((counter_now - counter_last)>transmit_duration){
 800a6ec:	68fa      	ldr	r2, [r7, #12]
 800a6ee:	693b      	ldr	r3, [r7, #16]
 800a6f0:	1ad3      	subs	r3, r2, r3
 800a6f2:	68ba      	ldr	r2, [r7, #8]
 800a6f4:	429a      	cmp	r2, r3
 800a6f6:	d2f4      	bcs.n	800a6e2 <main+0x62>
  if(data[0]<=0xAE){
 800a6f8:	783b      	ldrb	r3, [r7, #0]
 800a6fa:	2bae      	cmp	r3, #174	@ 0xae
 800a6fc:	d804      	bhi.n	800a708 <main+0x88>
   data[0] +=1;
 800a6fe:	783b      	ldrb	r3, [r7, #0]
 800a700:	3301      	adds	r3, #1
 800a702:	b2db      	uxtb	r3, r3
 800a704:	703b      	strb	r3, [r7, #0]
 800a706:	e005      	b.n	800a714 <main+0x94>
   }
   else{
 	data[0] = 0;
 800a708:	2300      	movs	r3, #0
 800a70a:	703b      	strb	r3, [r7, #0]
 	data[1] += 1;
 800a70c:	787b      	ldrb	r3, [r7, #1]
 800a70e:	3301      	adds	r3, #1
 800a710:	b2db      	uxtb	r3, r3
 800a712:	707b      	strb	r3, [r7, #1]
   }
  HAL_CAN_AddTxMessage(&canHandle,&Txheader,data,&TxMailBox);
 800a714:	463a      	mov	r2, r7
 800a716:	4b06      	ldr	r3, [pc, #24]	@ (800a730 <main+0xb0>)
 800a718:	4904      	ldr	r1, [pc, #16]	@ (800a72c <main+0xac>)
 800a71a:	4803      	ldr	r0, [pc, #12]	@ (800a728 <main+0xa8>)
 800a71c:	f000 fc15 	bl	800af4a <HAL_CAN_AddTxMessage>
  //HAL_Delay(50);
  counter_last = counter_now;
 800a720:	68fb      	ldr	r3, [r7, #12]
 800a722:	613b      	str	r3, [r7, #16]
  AppTask();
 800a724:	e7dd      	b.n	800a6e2 <main+0x62>
 800a726:	bf00      	nop
 800a728:	20000028 	.word	0x20000028
 800a72c:	20000058 	.word	0x20000058
 800a730:	20000070 	.word	0x20000070

0800a734 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800a734:	b580      	push	{r7, lr}
 800a736:	b0a6      	sub	sp, #152	@ 0x98
 800a738:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800a73a:	f107 0370 	add.w	r3, r7, #112	@ 0x70
 800a73e:	2228      	movs	r2, #40	@ 0x28
 800a740:	2100      	movs	r1, #0
 800a742:	4618      	mov	r0, r3
 800a744:	f002 fcac 	bl	800d0a0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800a748:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
 800a74c:	2200      	movs	r2, #0
 800a74e:	601a      	str	r2, [r3, #0]
 800a750:	605a      	str	r2, [r3, #4]
 800a752:	609a      	str	r2, [r3, #8]
 800a754:	60da      	str	r2, [r3, #12]
 800a756:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800a758:	1d3b      	adds	r3, r7, #4
 800a75a:	2258      	movs	r2, #88	@ 0x58
 800a75c:	2100      	movs	r1, #0
 800a75e:	4618      	mov	r0, r3
 800a760:	f002 fc9e 	bl	800d0a0 <memset>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800a764:	2302      	movs	r3, #2
 800a766:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800a768:	2301      	movs	r3, #1
 800a76a:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800a76c:	2310      	movs	r3, #16
 800a76e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800a772:	2302      	movs	r3, #2
 800a774:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800a778:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800a77c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 800a780:	f44f 13e0 	mov.w	r3, #1835008	@ 0x1c0000
 800a784:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 800a788:	2300      	movs	r3, #0
 800a78a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800a78e:	f107 0370 	add.w	r3, r7, #112	@ 0x70
 800a792:	4618      	mov	r0, r3
 800a794:	f001 f854 	bl	800b840 <HAL_RCC_OscConfig>
 800a798:	4603      	mov	r3, r0
 800a79a:	2b00      	cmp	r3, #0
 800a79c:	d001      	beq.n	800a7a2 <SystemClock_Config+0x6e>
  {
    Error_Handler();
 800a79e:	f000 f88b 	bl	800a8b8 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800a7a2:	230f      	movs	r3, #15
 800a7a4:	65fb      	str	r3, [r7, #92]	@ 0x5c
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800a7a6:	2302      	movs	r3, #2
 800a7a8:	663b      	str	r3, [r7, #96]	@ 0x60
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800a7aa:	2300      	movs	r3, #0
 800a7ac:	667b      	str	r3, [r7, #100]	@ 0x64
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800a7ae:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800a7b2:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800a7b4:	2300      	movs	r3, #0
 800a7b6:	66fb      	str	r3, [r7, #108]	@ 0x6c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800a7b8:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
 800a7bc:	2102      	movs	r1, #2
 800a7be:	4618      	mov	r0, r3
 800a7c0:	f002 f862 	bl	800c888 <HAL_RCC_ClockConfig>
 800a7c4:	4603      	mov	r3, r0
 800a7c6:	2b00      	cmp	r3, #0
 800a7c8:	d001      	beq.n	800a7ce <SystemClock_Config+0x9a>
  {
    Error_Handler();
 800a7ca:	f000 f875 	bl	800a8b8 <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 800a7ce:	2302      	movs	r3, #2
 800a7d0:	607b      	str	r3, [r7, #4]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 800a7d2:	2300      	movs	r3, #0
 800a7d4:	613b      	str	r3, [r7, #16]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800a7d6:	1d3b      	adds	r3, r7, #4
 800a7d8:	4618      	mov	r0, r3
 800a7da:	f002 fa45 	bl	800cc68 <HAL_RCCEx_PeriphCLKConfig>
 800a7de:	4603      	mov	r3, r0
 800a7e0:	2b00      	cmp	r3, #0
 800a7e2:	d001      	beq.n	800a7e8 <SystemClock_Config+0xb4>
  {
    Error_Handler();
 800a7e4:	f000 f868 	bl	800a8b8 <Error_Handler>
  }
}
 800a7e8:	bf00      	nop
 800a7ea:	3798      	adds	r7, #152	@ 0x98
 800a7ec:	46bd      	mov	sp, r7
 800a7ee:	bd80      	pop	{r7, pc}

0800a7f0 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800a7f0:	b580      	push	{r7, lr}
 800a7f2:	b08a      	sub	sp, #40	@ 0x28
 800a7f4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a7f6:	f107 0314 	add.w	r3, r7, #20
 800a7fa:	2200      	movs	r2, #0
 800a7fc:	601a      	str	r2, [r3, #0]
 800a7fe:	605a      	str	r2, [r3, #4]
 800a800:	609a      	str	r2, [r3, #8]
 800a802:	60da      	str	r2, [r3, #12]
 800a804:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800a806:	4b2b      	ldr	r3, [pc, #172]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a808:	695b      	ldr	r3, [r3, #20]
 800a80a:	4a2a      	ldr	r2, [pc, #168]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a80c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800a810:	6153      	str	r3, [r2, #20]
 800a812:	4b28      	ldr	r3, [pc, #160]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a814:	695b      	ldr	r3, [r3, #20]
 800a816:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800a81a:	613b      	str	r3, [r7, #16]
 800a81c:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800a81e:	4b25      	ldr	r3, [pc, #148]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a820:	695b      	ldr	r3, [r3, #20]
 800a822:	4a24      	ldr	r2, [pc, #144]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a824:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 800a828:	6153      	str	r3, [r2, #20]
 800a82a:	4b22      	ldr	r3, [pc, #136]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a82c:	695b      	ldr	r3, [r3, #20]
 800a82e:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800a832:	60fb      	str	r3, [r7, #12]
 800a834:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800a836:	4b1f      	ldr	r3, [pc, #124]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a838:	695b      	ldr	r3, [r3, #20]
 800a83a:	4a1e      	ldr	r2, [pc, #120]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a83c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800a840:	6153      	str	r3, [r2, #20]
 800a842:	4b1c      	ldr	r3, [pc, #112]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a844:	695b      	ldr	r3, [r3, #20]
 800a846:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800a84a:	60bb      	str	r3, [r7, #8]
 800a84c:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800a84e:	4b19      	ldr	r3, [pc, #100]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a850:	695b      	ldr	r3, [r3, #20]
 800a852:	4a18      	ldr	r2, [pc, #96]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a854:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800a858:	6153      	str	r3, [r2, #20]
 800a85a:	4b16      	ldr	r3, [pc, #88]	@ (800a8b4 <MX_GPIO_Init+0xc4>)
 800a85c:	695b      	ldr	r3, [r3, #20]
 800a85e:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800a862:	607b      	str	r3, [r7, #4]
 800a864:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 800a866:	2200      	movs	r2, #0
 800a868:	2120      	movs	r1, #32
 800a86a:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800a86e:	f000 ffcf 	bl	800b810 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PA0 */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a872:	2301      	movs	r3, #1
 800a874:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800a876:	2300      	movs	r3, #0
 800a878:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a87a:	2300      	movs	r3, #0
 800a87c:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a87e:	f107 0314 	add.w	r3, r7, #20
 800a882:	4619      	mov	r1, r3
 800a884:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800a888:	f000 fe38 	bl	800b4fc <HAL_GPIO_Init>

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
 800a88c:	2320      	movs	r3, #32
 800a88e:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a890:	2301      	movs	r3, #1
 800a892:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a894:	2300      	movs	r3, #0
 800a896:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a898:	2300      	movs	r3, #0
 800a89a:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 800a89c:	f107 0314 	add.w	r3, r7, #20
 800a8a0:	4619      	mov	r1, r3
 800a8a2:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800a8a6:	f000 fe29 	bl	800b4fc <HAL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 800a8aa:	bf00      	nop
 800a8ac:	3728      	adds	r7, #40	@ 0x28
 800a8ae:	46bd      	mov	sp, r7
 800a8b0:	bd80      	pop	{r7, pc}
 800a8b2:	bf00      	nop
 800a8b4:	40021000 	.word	0x40021000

0800a8b8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800a8b8:	b480      	push	{r7}
 800a8ba:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800a8bc:	b672      	cpsid	i
}
 800a8be:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800a8c0:	bf00      	nop
 800a8c2:	e7fd      	b.n	800a8c0 <Error_Handler+0x8>

0800a8c4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800a8c4:	b580      	push	{r7, lr}
 800a8c6:	b082      	sub	sp, #8
 800a8c8:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a8ca:	4b0f      	ldr	r3, [pc, #60]	@ (800a908 <HAL_MspInit+0x44>)
 800a8cc:	699b      	ldr	r3, [r3, #24]
 800a8ce:	4a0e      	ldr	r2, [pc, #56]	@ (800a908 <HAL_MspInit+0x44>)
 800a8d0:	f043 0301 	orr.w	r3, r3, #1
 800a8d4:	6193      	str	r3, [r2, #24]
 800a8d6:	4b0c      	ldr	r3, [pc, #48]	@ (800a908 <HAL_MspInit+0x44>)
 800a8d8:	699b      	ldr	r3, [r3, #24]
 800a8da:	f003 0301 	and.w	r3, r3, #1
 800a8de:	607b      	str	r3, [r7, #4]
 800a8e0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800a8e2:	4b09      	ldr	r3, [pc, #36]	@ (800a908 <HAL_MspInit+0x44>)
 800a8e4:	69db      	ldr	r3, [r3, #28]
 800a8e6:	4a08      	ldr	r2, [pc, #32]	@ (800a908 <HAL_MspInit+0x44>)
 800a8e8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800a8ec:	61d3      	str	r3, [r2, #28]
 800a8ee:	4b06      	ldr	r3, [pc, #24]	@ (800a908 <HAL_MspInit+0x44>)
 800a8f0:	69db      	ldr	r3, [r3, #28]
 800a8f2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800a8f6:	603b      	str	r3, [r7, #0]
 800a8f8:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 800a8fa:	2007      	movs	r0, #7
 800a8fc:	f000 fdca 	bl	800b494 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800a900:	bf00      	nop
 800a902:	3708      	adds	r7, #8
 800a904:	46bd      	mov	sp, r7
 800a906:	bd80      	pop	{r7, pc}
 800a908:	40021000 	.word	0x40021000

0800a90c <HAL_CAN_MspInit>:
* This function configures the hardware resources used in this example
* @param hcan: CAN handle pointer
* @retval None
*/
void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 800a90c:	b580      	push	{r7, lr}
 800a90e:	b08a      	sub	sp, #40	@ 0x28
 800a910:	af00      	add	r7, sp, #0
 800a912:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a914:	f107 0314 	add.w	r3, r7, #20
 800a918:	2200      	movs	r2, #0
 800a91a:	601a      	str	r2, [r3, #0]
 800a91c:	605a      	str	r2, [r3, #4]
 800a91e:	609a      	str	r2, [r3, #8]
 800a920:	60da      	str	r2, [r3, #12]
 800a922:	611a      	str	r2, [r3, #16]
  if(hcan->Instance==CAN)
 800a924:	687b      	ldr	r3, [r7, #4]
 800a926:	681b      	ldr	r3, [r3, #0]
 800a928:	4a17      	ldr	r2, [pc, #92]	@ (800a988 <HAL_CAN_MspInit+0x7c>)
 800a92a:	4293      	cmp	r3, r2
 800a92c:	d128      	bne.n	800a980 <HAL_CAN_MspInit+0x74>
  {
  /* USER CODE BEGIN CAN_MspInit 0 */

  /* USER CODE END CAN_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CAN1_CLK_ENABLE();
 800a92e:	4b17      	ldr	r3, [pc, #92]	@ (800a98c <HAL_CAN_MspInit+0x80>)
 800a930:	69db      	ldr	r3, [r3, #28]
 800a932:	4a16      	ldr	r2, [pc, #88]	@ (800a98c <HAL_CAN_MspInit+0x80>)
 800a934:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 800a938:	61d3      	str	r3, [r2, #28]
 800a93a:	4b14      	ldr	r3, [pc, #80]	@ (800a98c <HAL_CAN_MspInit+0x80>)
 800a93c:	69db      	ldr	r3, [r3, #28]
 800a93e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800a942:	613b      	str	r3, [r7, #16]
 800a944:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800a946:	4b11      	ldr	r3, [pc, #68]	@ (800a98c <HAL_CAN_MspInit+0x80>)
 800a948:	695b      	ldr	r3, [r3, #20]
 800a94a:	4a10      	ldr	r2, [pc, #64]	@ (800a98c <HAL_CAN_MspInit+0x80>)
 800a94c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800a950:	6153      	str	r3, [r2, #20]
 800a952:	4b0e      	ldr	r3, [pc, #56]	@ (800a98c <HAL_CAN_MspInit+0x80>)
 800a954:	695b      	ldr	r3, [r3, #20]
 800a956:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800a95a:	60fb      	str	r3, [r7, #12]
 800a95c:	68fb      	ldr	r3, [r7, #12]
    /**CAN GPIO Configuration
    PB8     ------> CAN_RX
    PB9     ------> CAN_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 800a95e:	f44f 7340 	mov.w	r3, #768	@ 0x300
 800a962:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a964:	2302      	movs	r3, #2
 800a966:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a968:	2300      	movs	r3, #0
 800a96a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a96c:	2303      	movs	r3, #3
 800a96e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN;
 800a970:	2309      	movs	r3, #9
 800a972:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a974:	f107 0314 	add.w	r3, r7, #20
 800a978:	4619      	mov	r1, r3
 800a97a:	4805      	ldr	r0, [pc, #20]	@ (800a990 <HAL_CAN_MspInit+0x84>)
 800a97c:	f000 fdbe 	bl	800b4fc <HAL_GPIO_Init>
  /* USER CODE BEGIN CAN_MspInit 1 */

  /* USER CODE END CAN_MspInit 1 */
  }

}
 800a980:	bf00      	nop
 800a982:	3728      	adds	r7, #40	@ 0x28
 800a984:	46bd      	mov	sp, r7
 800a986:	bd80      	pop	{r7, pc}
 800a988:	40006400 	.word	0x40006400
 800a98c:	40021000 	.word	0x40021000
 800a990:	48000400 	.word	0x48000400

0800a994 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800a994:	b480      	push	{r7}
 800a996:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 800a998:	bf00      	nop
 800a99a:	e7fd      	b.n	800a998 <NMI_Handler+0x4>

0800a99c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800a99c:	b480      	push	{r7}
 800a99e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800a9a0:	bf00      	nop
 800a9a2:	e7fd      	b.n	800a9a0 <HardFault_Handler+0x4>

0800a9a4 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800a9a4:	b480      	push	{r7}
 800a9a6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800a9a8:	bf00      	nop
 800a9aa:	e7fd      	b.n	800a9a8 <MemManage_Handler+0x4>

0800a9ac <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800a9ac:	b480      	push	{r7}
 800a9ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800a9b0:	bf00      	nop
 800a9b2:	e7fd      	b.n	800a9b0 <BusFault_Handler+0x4>

0800a9b4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800a9b4:	b480      	push	{r7}
 800a9b6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800a9b8:	bf00      	nop
 800a9ba:	e7fd      	b.n	800a9b8 <UsageFault_Handler+0x4>

0800a9bc <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800a9bc:	b480      	push	{r7}
 800a9be:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800a9c0:	bf00      	nop
 800a9c2:	46bd      	mov	sp, r7
 800a9c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9c8:	4770      	bx	lr

0800a9ca <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800a9ca:	b480      	push	{r7}
 800a9cc:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800a9ce:	bf00      	nop
 800a9d0:	46bd      	mov	sp, r7
 800a9d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9d6:	4770      	bx	lr

0800a9d8 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800a9d8:	b480      	push	{r7}
 800a9da:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800a9dc:	bf00      	nop
 800a9de:	46bd      	mov	sp, r7
 800a9e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a9e4:	4770      	bx	lr

0800a9e6 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800a9e6:	b580      	push	{r7, lr}
 800a9e8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800a9ea:	f000 f885 	bl	800aaf8 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800a9ee:	bf00      	nop
 800a9f0:	bd80      	pop	{r7, pc}
	...

0800a9f4 <SystemInit>:
  * @brief  Setup the microcontroller system
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800a9f4:	b480      	push	{r7}
 800a9f6:	af00      	add	r7, sp, #0
/* FPU settings --------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a9f8:	4b06      	ldr	r3, [pc, #24]	@ (800aa14 <SystemInit+0x20>)
 800a9fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800a9fe:	4a05      	ldr	r2, [pc, #20]	@ (800aa14 <SystemInit+0x20>)
 800aa00:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800aa04:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800aa08:	bf00      	nop
 800aa0a:	46bd      	mov	sp, r7
 800aa0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa10:	4770      	bx	lr
 800aa12:	bf00      	nop
 800aa14:	e000ed00 	.word	0xe000ed00

0800aa18 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800aa18:	f8df d034 	ldr.w	sp, [pc, #52]	@ 800aa50 <LoopForever+0x2>
  
/* Call the clock system initialization function.*/
    bl  SystemInit
 800aa1c:	f7ff ffea 	bl	800a9f4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800aa20:	480c      	ldr	r0, [pc, #48]	@ (800aa54 <LoopForever+0x6>)
  ldr r1, =_edata
 800aa22:	490d      	ldr	r1, [pc, #52]	@ (800aa58 <LoopForever+0xa>)
  ldr r2, =_sidata
 800aa24:	4a0d      	ldr	r2, [pc, #52]	@ (800aa5c <LoopForever+0xe>)
  movs r3, #0
 800aa26:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800aa28:	e002      	b.n	800aa30 <LoopCopyDataInit>

0800aa2a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800aa2a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800aa2c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800aa2e:	3304      	adds	r3, #4

0800aa30 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800aa30:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800aa32:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800aa34:	d3f9      	bcc.n	800aa2a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800aa36:	4a0a      	ldr	r2, [pc, #40]	@ (800aa60 <LoopForever+0x12>)
  ldr r4, =_ebss
 800aa38:	4c0a      	ldr	r4, [pc, #40]	@ (800aa64 <LoopForever+0x16>)
  movs r3, #0
 800aa3a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800aa3c:	e001      	b.n	800aa42 <LoopFillZerobss>

0800aa3e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800aa3e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800aa40:	3204      	adds	r2, #4

0800aa42 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800aa42:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800aa44:	d3fb      	bcc.n	800aa3e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800aa46:	f002 fb33 	bl	800d0b0 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800aa4a:	f7ff fe19 	bl	800a680 <main>

0800aa4e <LoopForever>:

LoopForever:
    b LoopForever
 800aa4e:	e7fe      	b.n	800aa4e <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800aa50:	20010000 	.word	0x20010000
  ldr r0, =_sdata
 800aa54:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800aa58:	2000000c 	.word	0x2000000c
  ldr r2, =_sidata
 800aa5c:	0800d174 	.word	0x0800d174
  ldr r2, =_sbss
 800aa60:	2000000c 	.word	0x2000000c
  ldr r4, =_ebss
 800aa64:	20000078 	.word	0x20000078

0800aa68 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800aa68:	e7fe      	b.n	800aa68 <ADC1_2_IRQHandler>
	...

0800aa6c <HAL_Init>:
  *         In the default implementation,Systick is used as source of time base.
  *       The tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800aa6c:	b580      	push	{r7, lr}
 800aa6e:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800aa70:	4b08      	ldr	r3, [pc, #32]	@ (800aa94 <HAL_Init+0x28>)
 800aa72:	681b      	ldr	r3, [r3, #0]
 800aa74:	4a07      	ldr	r2, [pc, #28]	@ (800aa94 <HAL_Init+0x28>)
 800aa76:	f043 0310 	orr.w	r3, r3, #16
 800aa7a:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800aa7c:	2003      	movs	r0, #3
 800aa7e:	f000 fd09 	bl	800b494 <HAL_NVIC_SetPriorityGrouping>

  /* Enable systick and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800aa82:	2000      	movs	r0, #0
 800aa84:	f000 f808 	bl	800aa98 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800aa88:	f7ff ff1c 	bl	800a8c4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800aa8c:	2300      	movs	r3, #0
}
 800aa8e:	4618      	mov	r0, r3
 800aa90:	bd80      	pop	{r7, pc}
 800aa92:	bf00      	nop
 800aa94:	40022000 	.word	0x40022000

0800aa98 <HAL_InitTick>:
  *         implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800aa98:	b580      	push	{r7, lr}
 800aa9a:	b082      	sub	sp, #8
 800aa9c:	af00      	add	r7, sp, #0
 800aa9e:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800aaa0:	4b12      	ldr	r3, [pc, #72]	@ (800aaec <HAL_InitTick+0x54>)
 800aaa2:	681a      	ldr	r2, [r3, #0]
 800aaa4:	4b12      	ldr	r3, [pc, #72]	@ (800aaf0 <HAL_InitTick+0x58>)
 800aaa6:	781b      	ldrb	r3, [r3, #0]
 800aaa8:	4619      	mov	r1, r3
 800aaaa:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800aaae:	fbb3 f3f1 	udiv	r3, r3, r1
 800aab2:	fbb2 f3f3 	udiv	r3, r2, r3
 800aab6:	4618      	mov	r0, r3
 800aab8:	f000 fd13 	bl	800b4e2 <HAL_SYSTICK_Config>
 800aabc:	4603      	mov	r3, r0
 800aabe:	2b00      	cmp	r3, #0
 800aac0:	d001      	beq.n	800aac6 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 800aac2:	2301      	movs	r3, #1
 800aac4:	e00e      	b.n	800aae4 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800aac6:	687b      	ldr	r3, [r7, #4]
 800aac8:	2b0f      	cmp	r3, #15
 800aaca:	d80a      	bhi.n	800aae2 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800aacc:	2200      	movs	r2, #0
 800aace:	6879      	ldr	r1, [r7, #4]
 800aad0:	f04f 30ff 	mov.w	r0, #4294967295
 800aad4:	f000 fce9 	bl	800b4aa <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800aad8:	4a06      	ldr	r2, [pc, #24]	@ (800aaf4 <HAL_InitTick+0x5c>)
 800aada:	687b      	ldr	r3, [r7, #4]
 800aadc:	6013      	str	r3, [r2, #0]
  else
  {
    return HAL_ERROR;
  }
   /* Return function status */
  return HAL_OK;
 800aade:	2300      	movs	r3, #0
 800aae0:	e000      	b.n	800aae4 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 800aae2:	2301      	movs	r3, #1
}
 800aae4:	4618      	mov	r0, r3
 800aae6:	3708      	adds	r7, #8
 800aae8:	46bd      	mov	sp, r7
 800aaea:	bd80      	pop	{r7, pc}
 800aaec:	20000000 	.word	0x20000000
 800aaf0:	20000008 	.word	0x20000008
 800aaf4:	20000004 	.word	0x20000004

0800aaf8 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *         implementations  in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800aaf8:	b480      	push	{r7}
 800aafa:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800aafc:	4b06      	ldr	r3, [pc, #24]	@ (800ab18 <HAL_IncTick+0x20>)
 800aafe:	781b      	ldrb	r3, [r3, #0]
 800ab00:	461a      	mov	r2, r3
 800ab02:	4b06      	ldr	r3, [pc, #24]	@ (800ab1c <HAL_IncTick+0x24>)
 800ab04:	681b      	ldr	r3, [r3, #0]
 800ab06:	4413      	add	r3, r2
 800ab08:	4a04      	ldr	r2, [pc, #16]	@ (800ab1c <HAL_IncTick+0x24>)
 800ab0a:	6013      	str	r3, [r2, #0]
}
 800ab0c:	bf00      	nop
 800ab0e:	46bd      	mov	sp, r7
 800ab10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab14:	4770      	bx	lr
 800ab16:	bf00      	nop
 800ab18:	20000008 	.word	0x20000008
 800ab1c:	20000074 	.word	0x20000074

0800ab20 <HAL_GetTick>:
  * @note   The function is declared as __Weak  to be overwritten  in case of other 
  *         implementations  in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800ab20:	b480      	push	{r7}
 800ab22:	af00      	add	r7, sp, #0
  return uwTick;  
 800ab24:	4b03      	ldr	r3, [pc, #12]	@ (800ab34 <HAL_GetTick+0x14>)
 800ab26:	681b      	ldr	r3, [r3, #0]
}
 800ab28:	4618      	mov	r0, r3
 800ab2a:	46bd      	mov	sp, r7
 800ab2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab30:	4770      	bx	lr
 800ab32:	bf00      	nop
 800ab34:	20000074 	.word	0x20000074

0800ab38 <HAL_CAN_Init>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
{
 800ab38:	b580      	push	{r7, lr}
 800ab3a:	b084      	sub	sp, #16
 800ab3c:	af00      	add	r7, sp, #0
 800ab3e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check CAN handle */
  if (hcan == NULL)
 800ab40:	687b      	ldr	r3, [r7, #4]
 800ab42:	2b00      	cmp	r3, #0
 800ab44:	d101      	bne.n	800ab4a <HAL_CAN_Init+0x12>
  {
    return HAL_ERROR;
 800ab46:	2301      	movs	r3, #1
 800ab48:	e0ed      	b.n	800ad26 <HAL_CAN_Init+0x1ee>
    /* Init the low level hardware: CLOCK, NVIC */
    hcan->MspInitCallback(hcan);
  }

#else
  if (hcan->State == HAL_CAN_STATE_RESET)
 800ab4a:	687b      	ldr	r3, [r7, #4]
 800ab4c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ab50:	b2db      	uxtb	r3, r3
 800ab52:	2b00      	cmp	r3, #0
 800ab54:	d102      	bne.n	800ab5c <HAL_CAN_Init+0x24>
  {
    /* Init the low level hardware: CLOCK, NVIC */
    HAL_CAN_MspInit(hcan);
 800ab56:	6878      	ldr	r0, [r7, #4]
 800ab58:	f7ff fed8 	bl	800a90c <HAL_CAN_MspInit>
  }
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */

  /* Request initialisation */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 800ab5c:	687b      	ldr	r3, [r7, #4]
 800ab5e:	681b      	ldr	r3, [r3, #0]
 800ab60:	681a      	ldr	r2, [r3, #0]
 800ab62:	687b      	ldr	r3, [r7, #4]
 800ab64:	681b      	ldr	r3, [r3, #0]
 800ab66:	f042 0201 	orr.w	r2, r2, #1
 800ab6a:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800ab6c:	f7ff ffd8 	bl	800ab20 <HAL_GetTick>
 800ab70:	60f8      	str	r0, [r7, #12]

  /* Wait initialisation acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 800ab72:	e012      	b.n	800ab9a <HAL_CAN_Init+0x62>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 800ab74:	f7ff ffd4 	bl	800ab20 <HAL_GetTick>
 800ab78:	4602      	mov	r2, r0
 800ab7a:	68fb      	ldr	r3, [r7, #12]
 800ab7c:	1ad3      	subs	r3, r2, r3
 800ab7e:	2b0a      	cmp	r3, #10
 800ab80:	d90b      	bls.n	800ab9a <HAL_CAN_Init+0x62>
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800ab82:	687b      	ldr	r3, [r7, #4]
 800ab84:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ab86:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 800ab8a:	687b      	ldr	r3, [r7, #4]
 800ab8c:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_ERROR;
 800ab8e:	687b      	ldr	r3, [r7, #4]
 800ab90:	2205      	movs	r2, #5
 800ab92:	f883 2020 	strb.w	r2, [r3, #32]

      return HAL_ERROR;
 800ab96:	2301      	movs	r3, #1
 800ab98:	e0c5      	b.n	800ad26 <HAL_CAN_Init+0x1ee>
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 800ab9a:	687b      	ldr	r3, [r7, #4]
 800ab9c:	681b      	ldr	r3, [r3, #0]
 800ab9e:	685b      	ldr	r3, [r3, #4]
 800aba0:	f003 0301 	and.w	r3, r3, #1
 800aba4:	2b00      	cmp	r3, #0
 800aba6:	d0e5      	beq.n	800ab74 <HAL_CAN_Init+0x3c>
    }
  }

  /* Exit from sleep mode */
  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
 800aba8:	687b      	ldr	r3, [r7, #4]
 800abaa:	681b      	ldr	r3, [r3, #0]
 800abac:	681a      	ldr	r2, [r3, #0]
 800abae:	687b      	ldr	r3, [r7, #4]
 800abb0:	681b      	ldr	r3, [r3, #0]
 800abb2:	f022 0202 	bic.w	r2, r2, #2
 800abb6:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 800abb8:	f7ff ffb2 	bl	800ab20 <HAL_GetTick>
 800abbc:	60f8      	str	r0, [r7, #12]

  /* Check Sleep mode leave acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 800abbe:	e012      	b.n	800abe6 <HAL_CAN_Init+0xae>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 800abc0:	f7ff ffae 	bl	800ab20 <HAL_GetTick>
 800abc4:	4602      	mov	r2, r0
 800abc6:	68fb      	ldr	r3, [r7, #12]
 800abc8:	1ad3      	subs	r3, r2, r3
 800abca:	2b0a      	cmp	r3, #10
 800abcc:	d90b      	bls.n	800abe6 <HAL_CAN_Init+0xae>
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800abce:	687b      	ldr	r3, [r7, #4]
 800abd0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800abd2:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 800abd6:	687b      	ldr	r3, [r7, #4]
 800abd8:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_ERROR;
 800abda:	687b      	ldr	r3, [r7, #4]
 800abdc:	2205      	movs	r2, #5
 800abde:	f883 2020 	strb.w	r2, [r3, #32]

      return HAL_ERROR;
 800abe2:	2301      	movs	r3, #1
 800abe4:	e09f      	b.n	800ad26 <HAL_CAN_Init+0x1ee>
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 800abe6:	687b      	ldr	r3, [r7, #4]
 800abe8:	681b      	ldr	r3, [r3, #0]
 800abea:	685b      	ldr	r3, [r3, #4]
 800abec:	f003 0302 	and.w	r3, r3, #2
 800abf0:	2b00      	cmp	r3, #0
 800abf2:	d1e5      	bne.n	800abc0 <HAL_CAN_Init+0x88>
    }
  }

  /* Set the time triggered communication mode */
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 800abf4:	687b      	ldr	r3, [r7, #4]
 800abf6:	7e1b      	ldrb	r3, [r3, #24]
 800abf8:	2b01      	cmp	r3, #1
 800abfa:	d108      	bne.n	800ac0e <HAL_CAN_Init+0xd6>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 800abfc:	687b      	ldr	r3, [r7, #4]
 800abfe:	681b      	ldr	r3, [r3, #0]
 800ac00:	681a      	ldr	r2, [r3, #0]
 800ac02:	687b      	ldr	r3, [r7, #4]
 800ac04:	681b      	ldr	r3, [r3, #0]
 800ac06:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 800ac0a:	601a      	str	r2, [r3, #0]
 800ac0c:	e007      	b.n	800ac1e <HAL_CAN_Init+0xe6>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 800ac0e:	687b      	ldr	r3, [r7, #4]
 800ac10:	681b      	ldr	r3, [r3, #0]
 800ac12:	681a      	ldr	r2, [r3, #0]
 800ac14:	687b      	ldr	r3, [r7, #4]
 800ac16:	681b      	ldr	r3, [r3, #0]
 800ac18:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 800ac1c:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic bus-off management */
  if (hcan->Init.AutoBusOff == ENABLE)
 800ac1e:	687b      	ldr	r3, [r7, #4]
 800ac20:	7e5b      	ldrb	r3, [r3, #25]
 800ac22:	2b01      	cmp	r3, #1
 800ac24:	d108      	bne.n	800ac38 <HAL_CAN_Init+0x100>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 800ac26:	687b      	ldr	r3, [r7, #4]
 800ac28:	681b      	ldr	r3, [r3, #0]
 800ac2a:	681a      	ldr	r2, [r3, #0]
 800ac2c:	687b      	ldr	r3, [r7, #4]
 800ac2e:	681b      	ldr	r3, [r3, #0]
 800ac30:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800ac34:	601a      	str	r2, [r3, #0]
 800ac36:	e007      	b.n	800ac48 <HAL_CAN_Init+0x110>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 800ac38:	687b      	ldr	r3, [r7, #4]
 800ac3a:	681b      	ldr	r3, [r3, #0]
 800ac3c:	681a      	ldr	r2, [r3, #0]
 800ac3e:	687b      	ldr	r3, [r7, #4]
 800ac40:	681b      	ldr	r3, [r3, #0]
 800ac42:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 800ac46:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic wake-up mode */
  if (hcan->Init.AutoWakeUp == ENABLE)
 800ac48:	687b      	ldr	r3, [r7, #4]
 800ac4a:	7e9b      	ldrb	r3, [r3, #26]
 800ac4c:	2b01      	cmp	r3, #1
 800ac4e:	d108      	bne.n	800ac62 <HAL_CAN_Init+0x12a>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 800ac50:	687b      	ldr	r3, [r7, #4]
 800ac52:	681b      	ldr	r3, [r3, #0]
 800ac54:	681a      	ldr	r2, [r3, #0]
 800ac56:	687b      	ldr	r3, [r7, #4]
 800ac58:	681b      	ldr	r3, [r3, #0]
 800ac5a:	f042 0220 	orr.w	r2, r2, #32
 800ac5e:	601a      	str	r2, [r3, #0]
 800ac60:	e007      	b.n	800ac72 <HAL_CAN_Init+0x13a>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 800ac62:	687b      	ldr	r3, [r7, #4]
 800ac64:	681b      	ldr	r3, [r3, #0]
 800ac66:	681a      	ldr	r2, [r3, #0]
 800ac68:	687b      	ldr	r3, [r7, #4]
 800ac6a:	681b      	ldr	r3, [r3, #0]
 800ac6c:	f022 0220 	bic.w	r2, r2, #32
 800ac70:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic retransmission */
  if (hcan->Init.AutoRetransmission == ENABLE)
 800ac72:	687b      	ldr	r3, [r7, #4]
 800ac74:	7edb      	ldrb	r3, [r3, #27]
 800ac76:	2b01      	cmp	r3, #1
 800ac78:	d108      	bne.n	800ac8c <HAL_CAN_Init+0x154>
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800ac7a:	687b      	ldr	r3, [r7, #4]
 800ac7c:	681b      	ldr	r3, [r3, #0]
 800ac7e:	681a      	ldr	r2, [r3, #0]
 800ac80:	687b      	ldr	r3, [r7, #4]
 800ac82:	681b      	ldr	r3, [r3, #0]
 800ac84:	f022 0210 	bic.w	r2, r2, #16
 800ac88:	601a      	str	r2, [r3, #0]
 800ac8a:	e007      	b.n	800ac9c <HAL_CAN_Init+0x164>
  }
  else
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800ac8c:	687b      	ldr	r3, [r7, #4]
 800ac8e:	681b      	ldr	r3, [r3, #0]
 800ac90:	681a      	ldr	r2, [r3, #0]
 800ac92:	687b      	ldr	r3, [r7, #4]
 800ac94:	681b      	ldr	r3, [r3, #0]
 800ac96:	f042 0210 	orr.w	r2, r2, #16
 800ac9a:	601a      	str	r2, [r3, #0]
  }

  /* Set the receive FIFO locked mode */
  if (hcan->Init.ReceiveFifoLocked == ENABLE)
 800ac9c:	687b      	ldr	r3, [r7, #4]
 800ac9e:	7f1b      	ldrb	r3, [r3, #28]
 800aca0:	2b01      	cmp	r3, #1
 800aca2:	d108      	bne.n	800acb6 <HAL_CAN_Init+0x17e>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 800aca4:	687b      	ldr	r3, [r7, #4]
 800aca6:	681b      	ldr	r3, [r3, #0]
 800aca8:	681a      	ldr	r2, [r3, #0]
 800acaa:	687b      	ldr	r3, [r7, #4]
 800acac:	681b      	ldr	r3, [r3, #0]
 800acae:	f042 0208 	orr.w	r2, r2, #8
 800acb2:	601a      	str	r2, [r3, #0]
 800acb4:	e007      	b.n	800acc6 <HAL_CAN_Init+0x18e>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 800acb6:	687b      	ldr	r3, [r7, #4]
 800acb8:	681b      	ldr	r3, [r3, #0]
 800acba:	681a      	ldr	r2, [r3, #0]
 800acbc:	687b      	ldr	r3, [r7, #4]
 800acbe:	681b      	ldr	r3, [r3, #0]
 800acc0:	f022 0208 	bic.w	r2, r2, #8
 800acc4:	601a      	str	r2, [r3, #0]
  }

  /* Set the transmit FIFO priority */
  if (hcan->Init.TransmitFifoPriority == ENABLE)
 800acc6:	687b      	ldr	r3, [r7, #4]
 800acc8:	7f5b      	ldrb	r3, [r3, #29]
 800acca:	2b01      	cmp	r3, #1
 800accc:	d108      	bne.n	800ace0 <HAL_CAN_Init+0x1a8>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 800acce:	687b      	ldr	r3, [r7, #4]
 800acd0:	681b      	ldr	r3, [r3, #0]
 800acd2:	681a      	ldr	r2, [r3, #0]
 800acd4:	687b      	ldr	r3, [r7, #4]
 800acd6:	681b      	ldr	r3, [r3, #0]
 800acd8:	f042 0204 	orr.w	r2, r2, #4
 800acdc:	601a      	str	r2, [r3, #0]
 800acde:	e007      	b.n	800acf0 <HAL_CAN_Init+0x1b8>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 800ace0:	687b      	ldr	r3, [r7, #4]
 800ace2:	681b      	ldr	r3, [r3, #0]
 800ace4:	681a      	ldr	r2, [r3, #0]
 800ace6:	687b      	ldr	r3, [r7, #4]
 800ace8:	681b      	ldr	r3, [r3, #0]
 800acea:	f022 0204 	bic.w	r2, r2, #4
 800acee:	601a      	str	r2, [r3, #0]
  }

  /* Set the bit timing register */
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 800acf0:	687b      	ldr	r3, [r7, #4]
 800acf2:	689a      	ldr	r2, [r3, #8]
 800acf4:	687b      	ldr	r3, [r7, #4]
 800acf6:	68db      	ldr	r3, [r3, #12]
 800acf8:	431a      	orrs	r2, r3
 800acfa:	687b      	ldr	r3, [r7, #4]
 800acfc:	691b      	ldr	r3, [r3, #16]
 800acfe:	431a      	orrs	r2, r3
 800ad00:	687b      	ldr	r3, [r7, #4]
 800ad02:	695b      	ldr	r3, [r3, #20]
 800ad04:	ea42 0103 	orr.w	r1, r2, r3
 800ad08:	687b      	ldr	r3, [r7, #4]
 800ad0a:	685b      	ldr	r3, [r3, #4]
 800ad0c:	1e5a      	subs	r2, r3, #1
 800ad0e:	687b      	ldr	r3, [r7, #4]
 800ad10:	681b      	ldr	r3, [r3, #0]
 800ad12:	430a      	orrs	r2, r1
 800ad14:	61da      	str	r2, [r3, #28]
                                            hcan->Init.TimeSeg1       |
                                            hcan->Init.TimeSeg2       |
                                            (hcan->Init.Prescaler - 1U)));

  /* Initialize the error code */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 800ad16:	687b      	ldr	r3, [r7, #4]
 800ad18:	2200      	movs	r2, #0
 800ad1a:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Initialize the CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 800ad1c:	687b      	ldr	r3, [r7, #4]
 800ad1e:	2201      	movs	r2, #1
 800ad20:	f883 2020 	strb.w	r2, [r3, #32]

  /* Return function status */
  return HAL_OK;
 800ad24:	2300      	movs	r3, #0
}
 800ad26:	4618      	mov	r0, r3
 800ad28:	3710      	adds	r7, #16
 800ad2a:	46bd      	mov	sp, r7
 800ad2c:	bd80      	pop	{r7, pc}

0800ad2e <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig pointer to a CAN_FilterTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, const CAN_FilterTypeDef *sFilterConfig)
{
 800ad2e:	b480      	push	{r7}
 800ad30:	b087      	sub	sp, #28
 800ad32:	af00      	add	r7, sp, #0
 800ad34:	6078      	str	r0, [r7, #4]
 800ad36:	6039      	str	r1, [r7, #0]
  uint32_t filternbrbitpos;
  CAN_TypeDef *can_ip = hcan->Instance;
 800ad38:	687b      	ldr	r3, [r7, #4]
 800ad3a:	681b      	ldr	r3, [r3, #0]
 800ad3c:	617b      	str	r3, [r7, #20]
  HAL_CAN_StateTypeDef state = hcan->State;
 800ad3e:	687b      	ldr	r3, [r7, #4]
 800ad40:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ad44:	74fb      	strb	r3, [r7, #19]

  if ((state == HAL_CAN_STATE_READY) ||
 800ad46:	7cfb      	ldrb	r3, [r7, #19]
 800ad48:	2b01      	cmp	r3, #1
 800ad4a:	d003      	beq.n	800ad54 <HAL_CAN_ConfigFilter+0x26>
 800ad4c:	7cfb      	ldrb	r3, [r7, #19]
 800ad4e:	2b02      	cmp	r3, #2
 800ad50:	f040 80aa 	bne.w	800aea8 <HAL_CAN_ConfigFilter+0x17a>

    /* Check the parameters */
    assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));

    /* Initialisation mode for the filter */
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 800ad54:	697b      	ldr	r3, [r7, #20]
 800ad56:	f8d3 3200 	ldr.w	r3, [r3, #512]	@ 0x200
 800ad5a:	f043 0201 	orr.w	r2, r3, #1
 800ad5e:	697b      	ldr	r3, [r7, #20]
 800ad60:	f8c3 2200 	str.w	r2, [r3, #512]	@ 0x200

    /* Convert filter number into bit position */
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 800ad64:	683b      	ldr	r3, [r7, #0]
 800ad66:	695b      	ldr	r3, [r3, #20]
 800ad68:	f003 031f 	and.w	r3, r3, #31
 800ad6c:	2201      	movs	r2, #1
 800ad6e:	fa02 f303 	lsl.w	r3, r2, r3
 800ad72:	60fb      	str	r3, [r7, #12]

    /* Filter Deactivation */
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 800ad74:	697b      	ldr	r3, [r7, #20]
 800ad76:	f8d3 221c 	ldr.w	r2, [r3, #540]	@ 0x21c
 800ad7a:	68fb      	ldr	r3, [r7, #12]
 800ad7c:	43db      	mvns	r3, r3
 800ad7e:	401a      	ands	r2, r3
 800ad80:	697b      	ldr	r3, [r7, #20]
 800ad82:	f8c3 221c 	str.w	r2, [r3, #540]	@ 0x21c

    /* Filter Scale */
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 800ad86:	683b      	ldr	r3, [r7, #0]
 800ad88:	69db      	ldr	r3, [r3, #28]
 800ad8a:	2b00      	cmp	r3, #0
 800ad8c:	d123      	bne.n	800add6 <HAL_CAN_ConfigFilter+0xa8>
    {
      /* 16-bit scale for the filter */
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 800ad8e:	697b      	ldr	r3, [r7, #20]
 800ad90:	f8d3 220c 	ldr.w	r2, [r3, #524]	@ 0x20c
 800ad94:	68fb      	ldr	r3, [r7, #12]
 800ad96:	43db      	mvns	r3, r3
 800ad98:	401a      	ands	r2, r3
 800ad9a:	697b      	ldr	r3, [r7, #20]
 800ad9c:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

      /* First 16-bit identifier and First 16-bit mask */
      /* Or First 16-bit identifier and Second 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 800ada0:	683b      	ldr	r3, [r7, #0]
 800ada2:	68db      	ldr	r3, [r3, #12]
 800ada4:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 800ada6:	683b      	ldr	r3, [r7, #0]
 800ada8:	685b      	ldr	r3, [r3, #4]
 800adaa:	b29b      	uxth	r3, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800adac:	683a      	ldr	r2, [r7, #0]
 800adae:	6952      	ldr	r2, [r2, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 800adb0:	4319      	orrs	r1, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800adb2:	697b      	ldr	r3, [r7, #20]
 800adb4:	3248      	adds	r2, #72	@ 0x48
 800adb6:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      /* Second 16-bit identifier and Second 16-bit mask */
      /* Or Third 16-bit identifier and Fourth 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800adba:	683b      	ldr	r3, [r7, #0]
 800adbc:	689b      	ldr	r3, [r3, #8]
 800adbe:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
 800adc0:	683b      	ldr	r3, [r7, #0]
 800adc2:	681b      	ldr	r3, [r3, #0]
 800adc4:	b29a      	uxth	r2, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800adc6:	683b      	ldr	r3, [r7, #0]
 800adc8:	695b      	ldr	r3, [r3, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800adca:	430a      	orrs	r2, r1
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800adcc:	6979      	ldr	r1, [r7, #20]
 800adce:	3348      	adds	r3, #72	@ 0x48
 800add0:	00db      	lsls	r3, r3, #3
 800add2:	440b      	add	r3, r1
 800add4:	605a      	str	r2, [r3, #4]
    }

    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 800add6:	683b      	ldr	r3, [r7, #0]
 800add8:	69db      	ldr	r3, [r3, #28]
 800adda:	2b01      	cmp	r3, #1
 800addc:	d122      	bne.n	800ae24 <HAL_CAN_ConfigFilter+0xf6>
    {
      /* 32-bit scale for the filter */
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 800adde:	697b      	ldr	r3, [r7, #20]
 800ade0:	f8d3 220c 	ldr.w	r2, [r3, #524]	@ 0x20c
 800ade4:	68fb      	ldr	r3, [r7, #12]
 800ade6:	431a      	orrs	r2, r3
 800ade8:	697b      	ldr	r3, [r7, #20]
 800adea:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

      /* 32-bit identifier or First 32-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 800adee:	683b      	ldr	r3, [r7, #0]
 800adf0:	681b      	ldr	r3, [r3, #0]
 800adf2:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 800adf4:	683b      	ldr	r3, [r7, #0]
 800adf6:	685b      	ldr	r3, [r3, #4]
 800adf8:	b29b      	uxth	r3, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800adfa:	683a      	ldr	r2, [r7, #0]
 800adfc:	6952      	ldr	r2, [r2, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 800adfe:	4319      	orrs	r1, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800ae00:	697b      	ldr	r3, [r7, #20]
 800ae02:	3248      	adds	r2, #72	@ 0x48
 800ae04:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      /* 32-bit mask or Second 32-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800ae08:	683b      	ldr	r3, [r7, #0]
 800ae0a:	689b      	ldr	r3, [r3, #8]
 800ae0c:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
 800ae0e:	683b      	ldr	r3, [r7, #0]
 800ae10:	68db      	ldr	r3, [r3, #12]
 800ae12:	b29a      	uxth	r2, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800ae14:	683b      	ldr	r3, [r7, #0]
 800ae16:	695b      	ldr	r3, [r3, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800ae18:	430a      	orrs	r2, r1
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 800ae1a:	6979      	ldr	r1, [r7, #20]
 800ae1c:	3348      	adds	r3, #72	@ 0x48
 800ae1e:	00db      	lsls	r3, r3, #3
 800ae20:	440b      	add	r3, r1
 800ae22:	605a      	str	r2, [r3, #4]
    }

    /* Filter Mode */
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 800ae24:	683b      	ldr	r3, [r7, #0]
 800ae26:	699b      	ldr	r3, [r3, #24]
 800ae28:	2b00      	cmp	r3, #0
 800ae2a:	d109      	bne.n	800ae40 <HAL_CAN_ConfigFilter+0x112>
    {
      /* Id/Mask mode for the filter*/
      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
 800ae2c:	697b      	ldr	r3, [r7, #20]
 800ae2e:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 800ae32:	68fb      	ldr	r3, [r7, #12]
 800ae34:	43db      	mvns	r3, r3
 800ae36:	401a      	ands	r2, r3
 800ae38:	697b      	ldr	r3, [r7, #20]
 800ae3a:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
 800ae3e:	e007      	b.n	800ae50 <HAL_CAN_ConfigFilter+0x122>
    }
    else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    {
      /* Identifier list mode for the filter*/
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 800ae40:	697b      	ldr	r3, [r7, #20]
 800ae42:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 800ae46:	68fb      	ldr	r3, [r7, #12]
 800ae48:	431a      	orrs	r2, r3
 800ae4a:	697b      	ldr	r3, [r7, #20]
 800ae4c:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
    }

    /* Filter FIFO assignment */
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 800ae50:	683b      	ldr	r3, [r7, #0]
 800ae52:	691b      	ldr	r3, [r3, #16]
 800ae54:	2b00      	cmp	r3, #0
 800ae56:	d109      	bne.n	800ae6c <HAL_CAN_ConfigFilter+0x13e>
    {
      /* FIFO 0 assignation for the filter */
      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
 800ae58:	697b      	ldr	r3, [r7, #20]
 800ae5a:	f8d3 2214 	ldr.w	r2, [r3, #532]	@ 0x214
 800ae5e:	68fb      	ldr	r3, [r7, #12]
 800ae60:	43db      	mvns	r3, r3
 800ae62:	401a      	ands	r2, r3
 800ae64:	697b      	ldr	r3, [r7, #20]
 800ae66:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
 800ae6a:	e007      	b.n	800ae7c <HAL_CAN_ConfigFilter+0x14e>
    }
    else
    {
      /* FIFO 1 assignation for the filter */
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 800ae6c:	697b      	ldr	r3, [r7, #20]
 800ae6e:	f8d3 2214 	ldr.w	r2, [r3, #532]	@ 0x214
 800ae72:	68fb      	ldr	r3, [r7, #12]
 800ae74:	431a      	orrs	r2, r3
 800ae76:	697b      	ldr	r3, [r7, #20]
 800ae78:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
    }

    /* Filter activation */
    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
 800ae7c:	683b      	ldr	r3, [r7, #0]
 800ae7e:	6a1b      	ldr	r3, [r3, #32]
 800ae80:	2b01      	cmp	r3, #1
 800ae82:	d107      	bne.n	800ae94 <HAL_CAN_ConfigFilter+0x166>
    {
      SET_BIT(can_ip->FA1R, filternbrbitpos);
 800ae84:	697b      	ldr	r3, [r7, #20]
 800ae86:	f8d3 221c 	ldr.w	r2, [r3, #540]	@ 0x21c
 800ae8a:	68fb      	ldr	r3, [r7, #12]
 800ae8c:	431a      	orrs	r2, r3
 800ae8e:	697b      	ldr	r3, [r7, #20]
 800ae90:	f8c3 221c 	str.w	r2, [r3, #540]	@ 0x21c
    }

    /* Leave the initialisation mode for the filter */
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 800ae94:	697b      	ldr	r3, [r7, #20]
 800ae96:	f8d3 3200 	ldr.w	r3, [r3, #512]	@ 0x200
 800ae9a:	f023 0201 	bic.w	r2, r3, #1
 800ae9e:	697b      	ldr	r3, [r7, #20]
 800aea0:	f8c3 2200 	str.w	r2, [r3, #512]	@ 0x200

    /* Return function status */
    return HAL_OK;
 800aea4:	2300      	movs	r3, #0
 800aea6:	e006      	b.n	800aeb6 <HAL_CAN_ConfigFilter+0x188>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800aea8:	687b      	ldr	r3, [r7, #4]
 800aeaa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aeac:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
 800aeb0:	687b      	ldr	r3, [r7, #4]
 800aeb2:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800aeb4:	2301      	movs	r3, #1
  }
}
 800aeb6:	4618      	mov	r0, r3
 800aeb8:	371c      	adds	r7, #28
 800aeba:	46bd      	mov	sp, r7
 800aebc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aec0:	4770      	bx	lr

0800aec2 <HAL_CAN_Start>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
{
 800aec2:	b580      	push	{r7, lr}
 800aec4:	b084      	sub	sp, #16
 800aec6:	af00      	add	r7, sp, #0
 800aec8:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  if (hcan->State == HAL_CAN_STATE_READY)
 800aeca:	687b      	ldr	r3, [r7, #4]
 800aecc:	f893 3020 	ldrb.w	r3, [r3, #32]
 800aed0:	b2db      	uxtb	r3, r3
 800aed2:	2b01      	cmp	r3, #1
 800aed4:	d12e      	bne.n	800af34 <HAL_CAN_Start+0x72>
  {
    /* Change CAN peripheral state */
    hcan->State = HAL_CAN_STATE_LISTENING;
 800aed6:	687b      	ldr	r3, [r7, #4]
 800aed8:	2202      	movs	r2, #2
 800aeda:	f883 2020 	strb.w	r2, [r3, #32]

    /* Request leave initialisation */
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 800aede:	687b      	ldr	r3, [r7, #4]
 800aee0:	681b      	ldr	r3, [r3, #0]
 800aee2:	681a      	ldr	r2, [r3, #0]
 800aee4:	687b      	ldr	r3, [r7, #4]
 800aee6:	681b      	ldr	r3, [r3, #0]
 800aee8:	f022 0201 	bic.w	r2, r2, #1
 800aeec:	601a      	str	r2, [r3, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 800aeee:	f7ff fe17 	bl	800ab20 <HAL_GetTick>
 800aef2:	60f8      	str	r0, [r7, #12]

    /* Wait the acknowledge */
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 800aef4:	e012      	b.n	800af1c <HAL_CAN_Start+0x5a>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 800aef6:	f7ff fe13 	bl	800ab20 <HAL_GetTick>
 800aefa:	4602      	mov	r2, r0
 800aefc:	68fb      	ldr	r3, [r7, #12]
 800aefe:	1ad3      	subs	r3, r2, r3
 800af00:	2b0a      	cmp	r3, #10
 800af02:	d90b      	bls.n	800af1c <HAL_CAN_Start+0x5a>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 800af04:	687b      	ldr	r3, [r7, #4]
 800af06:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800af08:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 800af0c:	687b      	ldr	r3, [r7, #4]
 800af0e:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Change CAN state */
        hcan->State = HAL_CAN_STATE_ERROR;
 800af10:	687b      	ldr	r3, [r7, #4]
 800af12:	2205      	movs	r2, #5
 800af14:	f883 2020 	strb.w	r2, [r3, #32]

        return HAL_ERROR;
 800af18:	2301      	movs	r3, #1
 800af1a:	e012      	b.n	800af42 <HAL_CAN_Start+0x80>
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 800af1c:	687b      	ldr	r3, [r7, #4]
 800af1e:	681b      	ldr	r3, [r3, #0]
 800af20:	685b      	ldr	r3, [r3, #4]
 800af22:	f003 0301 	and.w	r3, r3, #1
 800af26:	2b00      	cmp	r3, #0
 800af28:	d1e5      	bne.n	800aef6 <HAL_CAN_Start+0x34>
      }
    }

    /* Reset the CAN ErrorCode */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 800af2a:	687b      	ldr	r3, [r7, #4]
 800af2c:	2200      	movs	r2, #0
 800af2e:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Return function status */
    return HAL_OK;
 800af30:	2300      	movs	r3, #0
 800af32:	e006      	b.n	800af42 <HAL_CAN_Start+0x80>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 800af34:	687b      	ldr	r3, [r7, #4]
 800af36:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800af38:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
 800af3c:	687b      	ldr	r3, [r7, #4]
 800af3e:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800af40:	2301      	movs	r3, #1
  }
}
 800af42:	4618      	mov	r0, r3
 800af44:	3710      	adds	r7, #16
 800af46:	46bd      	mov	sp, r7
 800af48:	bd80      	pop	{r7, pc}

0800af4a <HAL_CAN_AddTxMessage>:
  *         This parameter can be a value of @arg CAN_Tx_Mailboxes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, const CAN_TxHeaderTypeDef *pHeader,
                                       const uint8_t aData[], uint32_t *pTxMailbox)
{
 800af4a:	b480      	push	{r7}
 800af4c:	b089      	sub	sp, #36	@ 0x24
 800af4e:	af00      	add	r7, sp, #0
 800af50:	60f8      	str	r0, [r7, #12]
 800af52:	60b9      	str	r1, [r7, #8]
 800af54:	607a      	str	r2, [r7, #4]
 800af56:	603b      	str	r3, [r7, #0]
  uint32_t transmitmailbox;
  HAL_CAN_StateTypeDef state = hcan->State;
 800af58:	68fb      	ldr	r3, [r7, #12]
 800af5a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800af5e:	77fb      	strb	r3, [r7, #31]
  uint32_t tsr = READ_REG(hcan->Instance->TSR);
 800af60:	68fb      	ldr	r3, [r7, #12]
 800af62:	681b      	ldr	r3, [r3, #0]
 800af64:	689b      	ldr	r3, [r3, #8]
 800af66:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_CAN_EXTID(pHeader->ExtId));
  }
  assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));

  if ((state == HAL_CAN_STATE_READY) ||
 800af68:	7ffb      	ldrb	r3, [r7, #31]
 800af6a:	2b01      	cmp	r3, #1
 800af6c:	d003      	beq.n	800af76 <HAL_CAN_AddTxMessage+0x2c>
 800af6e:	7ffb      	ldrb	r3, [r7, #31]
 800af70:	2b02      	cmp	r3, #2
 800af72:	f040 80ad 	bne.w	800b0d0 <HAL_CAN_AddTxMessage+0x186>
      (state == HAL_CAN_STATE_LISTENING))
  {
    /* Check that all the Tx mailboxes are not full */
    if (((tsr & CAN_TSR_TME0) != 0U) ||
 800af76:	69bb      	ldr	r3, [r7, #24]
 800af78:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 800af7c:	2b00      	cmp	r3, #0
 800af7e:	d10a      	bne.n	800af96 <HAL_CAN_AddTxMessage+0x4c>
        ((tsr & CAN_TSR_TME1) != 0U) ||
 800af80:	69bb      	ldr	r3, [r7, #24]
 800af82:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
    if (((tsr & CAN_TSR_TME0) != 0U) ||
 800af86:	2b00      	cmp	r3, #0
 800af88:	d105      	bne.n	800af96 <HAL_CAN_AddTxMessage+0x4c>
        ((tsr & CAN_TSR_TME2) != 0U))
 800af8a:	69bb      	ldr	r3, [r7, #24]
 800af8c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
        ((tsr & CAN_TSR_TME1) != 0U) ||
 800af90:	2b00      	cmp	r3, #0
 800af92:	f000 8095 	beq.w	800b0c0 <HAL_CAN_AddTxMessage+0x176>
    {
      /* Select an empty transmit mailbox */
      transmitmailbox = (tsr & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
 800af96:	69bb      	ldr	r3, [r7, #24]
 800af98:	0e1b      	lsrs	r3, r3, #24
 800af9a:	f003 0303 	and.w	r3, r3, #3
 800af9e:	617b      	str	r3, [r7, #20]

      /* Store the Tx mailbox */
      *pTxMailbox = (uint32_t)1 << transmitmailbox;
 800afa0:	2201      	movs	r2, #1
 800afa2:	697b      	ldr	r3, [r7, #20]
 800afa4:	409a      	lsls	r2, r3
 800afa6:	683b      	ldr	r3, [r7, #0]
 800afa8:	601a      	str	r2, [r3, #0]

      /* Set up the Id */
      if (pHeader->IDE == CAN_ID_STD)
 800afaa:	68bb      	ldr	r3, [r7, #8]
 800afac:	689b      	ldr	r3, [r3, #8]
 800afae:	2b00      	cmp	r3, #0
 800afb0:	d10d      	bne.n	800afce <HAL_CAN_AddTxMessage+0x84>
      {
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
 800afb2:	68bb      	ldr	r3, [r7, #8]
 800afb4:	681b      	ldr	r3, [r3, #0]
 800afb6:	055a      	lsls	r2, r3, #21
                                                           pHeader->RTR);
 800afb8:	68bb      	ldr	r3, [r7, #8]
 800afba:	68db      	ldr	r3, [r3, #12]
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
 800afbc:	68f9      	ldr	r1, [r7, #12]
 800afbe:	6809      	ldr	r1, [r1, #0]
 800afc0:	431a      	orrs	r2, r3
 800afc2:	697b      	ldr	r3, [r7, #20]
 800afc4:	3318      	adds	r3, #24
 800afc6:	011b      	lsls	r3, r3, #4
 800afc8:	440b      	add	r3, r1
 800afca:	601a      	str	r2, [r3, #0]
 800afcc:	e00f      	b.n	800afee <HAL_CAN_AddTxMessage+0xa4>
      }
      else
      {
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 800afce:	68bb      	ldr	r3, [r7, #8]
 800afd0:	685b      	ldr	r3, [r3, #4]
 800afd2:	00da      	lsls	r2, r3, #3
                                                           pHeader->IDE |
 800afd4:	68bb      	ldr	r3, [r7, #8]
 800afd6:	689b      	ldr	r3, [r3, #8]
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 800afd8:	431a      	orrs	r2, r3
                                                           pHeader->RTR);
 800afda:	68bb      	ldr	r3, [r7, #8]
 800afdc:	68db      	ldr	r3, [r3, #12]
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 800afde:	68f9      	ldr	r1, [r7, #12]
 800afe0:	6809      	ldr	r1, [r1, #0]
                                                           pHeader->IDE |
 800afe2:	431a      	orrs	r2, r3
        hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
 800afe4:	697b      	ldr	r3, [r7, #20]
 800afe6:	3318      	adds	r3, #24
 800afe8:	011b      	lsls	r3, r3, #4
 800afea:	440b      	add	r3, r1
 800afec:	601a      	str	r2, [r3, #0]
      }

      /* Set up the DLC */
      hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
 800afee:	68fb      	ldr	r3, [r7, #12]
 800aff0:	6819      	ldr	r1, [r3, #0]
 800aff2:	68bb      	ldr	r3, [r7, #8]
 800aff4:	691a      	ldr	r2, [r3, #16]
 800aff6:	697b      	ldr	r3, [r7, #20]
 800aff8:	3318      	adds	r3, #24
 800affa:	011b      	lsls	r3, r3, #4
 800affc:	440b      	add	r3, r1
 800affe:	3304      	adds	r3, #4
 800b000:	601a      	str	r2, [r3, #0]

      /* Set up the Transmit Global Time mode */
      if (pHeader->TransmitGlobalTime == ENABLE)
 800b002:	68bb      	ldr	r3, [r7, #8]
 800b004:	7d1b      	ldrb	r3, [r3, #20]
 800b006:	2b01      	cmp	r3, #1
 800b008:	d111      	bne.n	800b02e <HAL_CAN_AddTxMessage+0xe4>
      {
        SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);
 800b00a:	68fb      	ldr	r3, [r7, #12]
 800b00c:	681a      	ldr	r2, [r3, #0]
 800b00e:	697b      	ldr	r3, [r7, #20]
 800b010:	3318      	adds	r3, #24
 800b012:	011b      	lsls	r3, r3, #4
 800b014:	4413      	add	r3, r2
 800b016:	3304      	adds	r3, #4
 800b018:	681b      	ldr	r3, [r3, #0]
 800b01a:	68fa      	ldr	r2, [r7, #12]
 800b01c:	6811      	ldr	r1, [r2, #0]
 800b01e:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 800b022:	697b      	ldr	r3, [r7, #20]
 800b024:	3318      	adds	r3, #24
 800b026:	011b      	lsls	r3, r3, #4
 800b028:	440b      	add	r3, r1
 800b02a:	3304      	adds	r3, #4
 800b02c:	601a      	str	r2, [r3, #0]
      }

      /* Set up the data field */
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,
 800b02e:	687b      	ldr	r3, [r7, #4]
 800b030:	3307      	adds	r3, #7
 800b032:	781b      	ldrb	r3, [r3, #0]
 800b034:	061a      	lsls	r2, r3, #24
 800b036:	687b      	ldr	r3, [r7, #4]
 800b038:	3306      	adds	r3, #6
 800b03a:	781b      	ldrb	r3, [r3, #0]
 800b03c:	041b      	lsls	r3, r3, #16
 800b03e:	431a      	orrs	r2, r3
 800b040:	687b      	ldr	r3, [r7, #4]
 800b042:	3305      	adds	r3, #5
 800b044:	781b      	ldrb	r3, [r3, #0]
 800b046:	021b      	lsls	r3, r3, #8
 800b048:	4313      	orrs	r3, r2
 800b04a:	687a      	ldr	r2, [r7, #4]
 800b04c:	3204      	adds	r2, #4
 800b04e:	7812      	ldrb	r2, [r2, #0]
 800b050:	4610      	mov	r0, r2
 800b052:	68fa      	ldr	r2, [r7, #12]
 800b054:	6811      	ldr	r1, [r2, #0]
 800b056:	ea43 0200 	orr.w	r2, r3, r0
 800b05a:	697b      	ldr	r3, [r7, #20]
 800b05c:	011b      	lsls	r3, r3, #4
 800b05e:	440b      	add	r3, r1
 800b060:	f503 73c6 	add.w	r3, r3, #396	@ 0x18c
 800b064:	601a      	str	r2, [r3, #0]
                ((uint32_t)aData[7] << CAN_TDH0R_DATA7_Pos) |
                ((uint32_t)aData[6] << CAN_TDH0R_DATA6_Pos) |
                ((uint32_t)aData[5] << CAN_TDH0R_DATA5_Pos) |
                ((uint32_t)aData[4] << CAN_TDH0R_DATA4_Pos));
      WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
 800b066:	687b      	ldr	r3, [r7, #4]
 800b068:	3303      	adds	r3, #3
 800b06a:	781b      	ldrb	r3, [r3, #0]
 800b06c:	061a      	lsls	r2, r3, #24
 800b06e:	687b      	ldr	r3, [r7, #4]
 800b070:	3302      	adds	r3, #2
 800b072:	781b      	ldrb	r3, [r3, #0]
 800b074:	041b      	lsls	r3, r3, #16
 800b076:	431a      	orrs	r2, r3
 800b078:	687b      	ldr	r3, [r7, #4]
 800b07a:	3301      	adds	r3, #1
 800b07c:	781b      	ldrb	r3, [r3, #0]
 800b07e:	021b      	lsls	r3, r3, #8
 800b080:	4313      	orrs	r3, r2
 800b082:	687a      	ldr	r2, [r7, #4]
 800b084:	7812      	ldrb	r2, [r2, #0]
 800b086:	4610      	mov	r0, r2
 800b088:	68fa      	ldr	r2, [r7, #12]
 800b08a:	6811      	ldr	r1, [r2, #0]
 800b08c:	ea43 0200 	orr.w	r2, r3, r0
 800b090:	697b      	ldr	r3, [r7, #20]
 800b092:	011b      	lsls	r3, r3, #4
 800b094:	440b      	add	r3, r1
 800b096:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
 800b09a:	601a      	str	r2, [r3, #0]
                ((uint32_t)aData[2] << CAN_TDL0R_DATA2_Pos) |
                ((uint32_t)aData[1] << CAN_TDL0R_DATA1_Pos) |
                ((uint32_t)aData[0] << CAN_TDL0R_DATA0_Pos));

      /* Request transmission */
      SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);
 800b09c:	68fb      	ldr	r3, [r7, #12]
 800b09e:	681a      	ldr	r2, [r3, #0]
 800b0a0:	697b      	ldr	r3, [r7, #20]
 800b0a2:	3318      	adds	r3, #24
 800b0a4:	011b      	lsls	r3, r3, #4
 800b0a6:	4413      	add	r3, r2
 800b0a8:	681b      	ldr	r3, [r3, #0]
 800b0aa:	68fa      	ldr	r2, [r7, #12]
 800b0ac:	6811      	ldr	r1, [r2, #0]
 800b0ae:	f043 0201 	orr.w	r2, r3, #1
 800b0b2:	697b      	ldr	r3, [r7, #20]
 800b0b4:	3318      	adds	r3, #24
 800b0b6:	011b      	lsls	r3, r3, #4
 800b0b8:	440b      	add	r3, r1
 800b0ba:	601a      	str	r2, [r3, #0]

      /* Return function status */
      return HAL_OK;
 800b0bc:	2300      	movs	r3, #0
 800b0be:	e00e      	b.n	800b0de <HAL_CAN_AddTxMessage+0x194>
    }
    else
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 800b0c0:	68fb      	ldr	r3, [r7, #12]
 800b0c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b0c4:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 800b0c8:	68fb      	ldr	r3, [r7, #12]
 800b0ca:	625a      	str	r2, [r3, #36]	@ 0x24

      return HAL_ERROR;
 800b0cc:	2301      	movs	r3, #1
 800b0ce:	e006      	b.n	800b0de <HAL_CAN_AddTxMessage+0x194>
    }
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800b0d0:	68fb      	ldr	r3, [r7, #12]
 800b0d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b0d4:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
 800b0d8:	68fb      	ldr	r3, [r7, #12]
 800b0da:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800b0dc:	2301      	movs	r3, #1
  }
}
 800b0de:	4618      	mov	r0, r3
 800b0e0:	3724      	adds	r7, #36	@ 0x24
 800b0e2:	46bd      	mov	sp, r7
 800b0e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0e8:	4770      	bx	lr

0800b0ea <HAL_CAN_GetRxMessage>:
  * @param  aData array where the payload of the Rx frame will be stored.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo,
                                       CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
{
 800b0ea:	b480      	push	{r7}
 800b0ec:	b087      	sub	sp, #28
 800b0ee:	af00      	add	r7, sp, #0
 800b0f0:	60f8      	str	r0, [r7, #12]
 800b0f2:	60b9      	str	r1, [r7, #8]
 800b0f4:	607a      	str	r2, [r7, #4]
 800b0f6:	603b      	str	r3, [r7, #0]
  HAL_CAN_StateTypeDef state = hcan->State;
 800b0f8:	68fb      	ldr	r3, [r7, #12]
 800b0fa:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b0fe:	75fb      	strb	r3, [r7, #23]

  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((state == HAL_CAN_STATE_READY) ||
 800b100:	7dfb      	ldrb	r3, [r7, #23]
 800b102:	2b01      	cmp	r3, #1
 800b104:	d003      	beq.n	800b10e <HAL_CAN_GetRxMessage+0x24>
 800b106:	7dfb      	ldrb	r3, [r7, #23]
 800b108:	2b02      	cmp	r3, #2
 800b10a:	f040 8103 	bne.w	800b314 <HAL_CAN_GetRxMessage+0x22a>
      (state == HAL_CAN_STATE_LISTENING))
  {
    /* Check the Rx FIFO */
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 800b10e:	68bb      	ldr	r3, [r7, #8]
 800b110:	2b00      	cmp	r3, #0
 800b112:	d10e      	bne.n	800b132 <HAL_CAN_GetRxMessage+0x48>
    {
      /* Check that the Rx FIFO 0 is not empty */
      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
 800b114:	68fb      	ldr	r3, [r7, #12]
 800b116:	681b      	ldr	r3, [r3, #0]
 800b118:	68db      	ldr	r3, [r3, #12]
 800b11a:	f003 0303 	and.w	r3, r3, #3
 800b11e:	2b00      	cmp	r3, #0
 800b120:	d116      	bne.n	800b150 <HAL_CAN_GetRxMessage+0x66>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 800b122:	68fb      	ldr	r3, [r7, #12]
 800b124:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b126:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 800b12a:	68fb      	ldr	r3, [r7, #12]
 800b12c:	625a      	str	r2, [r3, #36]	@ 0x24

        return HAL_ERROR;
 800b12e:	2301      	movs	r3, #1
 800b130:	e0f7      	b.n	800b322 <HAL_CAN_GetRxMessage+0x238>
      }
    }
    else /* Rx element is assigned to Rx FIFO 1 */
    {
      /* Check that the Rx FIFO 1 is not empty */
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
 800b132:	68fb      	ldr	r3, [r7, #12]
 800b134:	681b      	ldr	r3, [r3, #0]
 800b136:	691b      	ldr	r3, [r3, #16]
 800b138:	f003 0303 	and.w	r3, r3, #3
 800b13c:	2b00      	cmp	r3, #0
 800b13e:	d107      	bne.n	800b150 <HAL_CAN_GetRxMessage+0x66>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 800b140:	68fb      	ldr	r3, [r7, #12]
 800b142:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b144:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 800b148:	68fb      	ldr	r3, [r7, #12]
 800b14a:	625a      	str	r2, [r3, #36]	@ 0x24

        return HAL_ERROR;
 800b14c:	2301      	movs	r3, #1
 800b14e:	e0e8      	b.n	800b322 <HAL_CAN_GetRxMessage+0x238>
      }
    }

    /* Get the header */
    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
 800b150:	68fb      	ldr	r3, [r7, #12]
 800b152:	681a      	ldr	r2, [r3, #0]
 800b154:	68bb      	ldr	r3, [r7, #8]
 800b156:	331b      	adds	r3, #27
 800b158:	011b      	lsls	r3, r3, #4
 800b15a:	4413      	add	r3, r2
 800b15c:	681b      	ldr	r3, [r3, #0]
 800b15e:	f003 0204 	and.w	r2, r3, #4
 800b162:	687b      	ldr	r3, [r7, #4]
 800b164:	609a      	str	r2, [r3, #8]
    if (pHeader->IDE == CAN_ID_STD)
 800b166:	687b      	ldr	r3, [r7, #4]
 800b168:	689b      	ldr	r3, [r3, #8]
 800b16a:	2b00      	cmp	r3, #0
 800b16c:	d10c      	bne.n	800b188 <HAL_CAN_GetRxMessage+0x9e>
    {
      pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
 800b16e:	68fb      	ldr	r3, [r7, #12]
 800b170:	681a      	ldr	r2, [r3, #0]
 800b172:	68bb      	ldr	r3, [r7, #8]
 800b174:	331b      	adds	r3, #27
 800b176:	011b      	lsls	r3, r3, #4
 800b178:	4413      	add	r3, r2
 800b17a:	681b      	ldr	r3, [r3, #0]
 800b17c:	0d5b      	lsrs	r3, r3, #21
 800b17e:	f3c3 020a 	ubfx	r2, r3, #0, #11
 800b182:	687b      	ldr	r3, [r7, #4]
 800b184:	601a      	str	r2, [r3, #0]
 800b186:	e00b      	b.n	800b1a0 <HAL_CAN_GetRxMessage+0xb6>
    }
    else
    {
      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) &
                        hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
 800b188:	68fb      	ldr	r3, [r7, #12]
 800b18a:	681a      	ldr	r2, [r3, #0]
 800b18c:	68bb      	ldr	r3, [r7, #8]
 800b18e:	331b      	adds	r3, #27
 800b190:	011b      	lsls	r3, r3, #4
 800b192:	4413      	add	r3, r2
 800b194:	681b      	ldr	r3, [r3, #0]
 800b196:	08db      	lsrs	r3, r3, #3
 800b198:	f023 4260 	bic.w	r2, r3, #3758096384	@ 0xe0000000
      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) &
 800b19c:	687b      	ldr	r3, [r7, #4]
 800b19e:	605a      	str	r2, [r3, #4]
    }
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
 800b1a0:	68fb      	ldr	r3, [r7, #12]
 800b1a2:	681a      	ldr	r2, [r3, #0]
 800b1a4:	68bb      	ldr	r3, [r7, #8]
 800b1a6:	331b      	adds	r3, #27
 800b1a8:	011b      	lsls	r3, r3, #4
 800b1aa:	4413      	add	r3, r2
 800b1ac:	681b      	ldr	r3, [r3, #0]
 800b1ae:	f003 0202 	and.w	r2, r3, #2
 800b1b2:	687b      	ldr	r3, [r7, #4]
 800b1b4:	60da      	str	r2, [r3, #12]
    if (((CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos) >= 8U)
 800b1b6:	68fb      	ldr	r3, [r7, #12]
 800b1b8:	681a      	ldr	r2, [r3, #0]
 800b1ba:	68bb      	ldr	r3, [r7, #8]
 800b1bc:	331b      	adds	r3, #27
 800b1be:	011b      	lsls	r3, r3, #4
 800b1c0:	4413      	add	r3, r2
 800b1c2:	3304      	adds	r3, #4
 800b1c4:	681b      	ldr	r3, [r3, #0]
 800b1c6:	f003 0308 	and.w	r3, r3, #8
 800b1ca:	2b00      	cmp	r3, #0
 800b1cc:	d003      	beq.n	800b1d6 <HAL_CAN_GetRxMessage+0xec>
    {
      /* Truncate DLC to 8 if received field is over range */
      pHeader->DLC = 8U;
 800b1ce:	687b      	ldr	r3, [r7, #4]
 800b1d0:	2208      	movs	r2, #8
 800b1d2:	611a      	str	r2, [r3, #16]
 800b1d4:	e00b      	b.n	800b1ee <HAL_CAN_GetRxMessage+0x104>
    }
    else
    {
      pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 800b1d6:	68fb      	ldr	r3, [r7, #12]
 800b1d8:	681a      	ldr	r2, [r3, #0]
 800b1da:	68bb      	ldr	r3, [r7, #8]
 800b1dc:	331b      	adds	r3, #27
 800b1de:	011b      	lsls	r3, r3, #4
 800b1e0:	4413      	add	r3, r2
 800b1e2:	3304      	adds	r3, #4
 800b1e4:	681b      	ldr	r3, [r3, #0]
 800b1e6:	f003 020f 	and.w	r2, r3, #15
 800b1ea:	687b      	ldr	r3, [r7, #4]
 800b1ec:	611a      	str	r2, [r3, #16]
    }
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 800b1ee:	68fb      	ldr	r3, [r7, #12]
 800b1f0:	681a      	ldr	r2, [r3, #0]
 800b1f2:	68bb      	ldr	r3, [r7, #8]
 800b1f4:	331b      	adds	r3, #27
 800b1f6:	011b      	lsls	r3, r3, #4
 800b1f8:	4413      	add	r3, r2
 800b1fa:	3304      	adds	r3, #4
 800b1fc:	681b      	ldr	r3, [r3, #0]
 800b1fe:	0a1b      	lsrs	r3, r3, #8
 800b200:	b2da      	uxtb	r2, r3
 800b202:	687b      	ldr	r3, [r7, #4]
 800b204:	619a      	str	r2, [r3, #24]
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 800b206:	68fb      	ldr	r3, [r7, #12]
 800b208:	681a      	ldr	r2, [r3, #0]
 800b20a:	68bb      	ldr	r3, [r7, #8]
 800b20c:	331b      	adds	r3, #27
 800b20e:	011b      	lsls	r3, r3, #4
 800b210:	4413      	add	r3, r2
 800b212:	3304      	adds	r3, #4
 800b214:	681b      	ldr	r3, [r3, #0]
 800b216:	0c1b      	lsrs	r3, r3, #16
 800b218:	b29a      	uxth	r2, r3
 800b21a:	687b      	ldr	r3, [r7, #4]
 800b21c:	615a      	str	r2, [r3, #20]

    /* Get the data */
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 800b21e:	68fb      	ldr	r3, [r7, #12]
 800b220:	681a      	ldr	r2, [r3, #0]
 800b222:	68bb      	ldr	r3, [r7, #8]
 800b224:	011b      	lsls	r3, r3, #4
 800b226:	4413      	add	r3, r2
 800b228:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800b22c:	681b      	ldr	r3, [r3, #0]
 800b22e:	b2da      	uxtb	r2, r3
 800b230:	683b      	ldr	r3, [r7, #0]
 800b232:	701a      	strb	r2, [r3, #0]
    aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
 800b234:	68fb      	ldr	r3, [r7, #12]
 800b236:	681a      	ldr	r2, [r3, #0]
 800b238:	68bb      	ldr	r3, [r7, #8]
 800b23a:	011b      	lsls	r3, r3, #4
 800b23c:	4413      	add	r3, r2
 800b23e:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800b242:	681b      	ldr	r3, [r3, #0]
 800b244:	0a1a      	lsrs	r2, r3, #8
 800b246:	683b      	ldr	r3, [r7, #0]
 800b248:	3301      	adds	r3, #1
 800b24a:	b2d2      	uxtb	r2, r2
 800b24c:	701a      	strb	r2, [r3, #0]
    aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
 800b24e:	68fb      	ldr	r3, [r7, #12]
 800b250:	681a      	ldr	r2, [r3, #0]
 800b252:	68bb      	ldr	r3, [r7, #8]
 800b254:	011b      	lsls	r3, r3, #4
 800b256:	4413      	add	r3, r2
 800b258:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800b25c:	681b      	ldr	r3, [r3, #0]
 800b25e:	0c1a      	lsrs	r2, r3, #16
 800b260:	683b      	ldr	r3, [r7, #0]
 800b262:	3302      	adds	r3, #2
 800b264:	b2d2      	uxtb	r2, r2
 800b266:	701a      	strb	r2, [r3, #0]
    aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
 800b268:	68fb      	ldr	r3, [r7, #12]
 800b26a:	681a      	ldr	r2, [r3, #0]
 800b26c:	68bb      	ldr	r3, [r7, #8]
 800b26e:	011b      	lsls	r3, r3, #4
 800b270:	4413      	add	r3, r2
 800b272:	f503 73dc 	add.w	r3, r3, #440	@ 0x1b8
 800b276:	681b      	ldr	r3, [r3, #0]
 800b278:	0e1a      	lsrs	r2, r3, #24
 800b27a:	683b      	ldr	r3, [r7, #0]
 800b27c:	3303      	adds	r3, #3
 800b27e:	b2d2      	uxtb	r2, r2
 800b280:	701a      	strb	r2, [r3, #0]
    aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
 800b282:	68fb      	ldr	r3, [r7, #12]
 800b284:	681a      	ldr	r2, [r3, #0]
 800b286:	68bb      	ldr	r3, [r7, #8]
 800b288:	011b      	lsls	r3, r3, #4
 800b28a:	4413      	add	r3, r2
 800b28c:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800b290:	681a      	ldr	r2, [r3, #0]
 800b292:	683b      	ldr	r3, [r7, #0]
 800b294:	3304      	adds	r3, #4
 800b296:	b2d2      	uxtb	r2, r2
 800b298:	701a      	strb	r2, [r3, #0]
    aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
 800b29a:	68fb      	ldr	r3, [r7, #12]
 800b29c:	681a      	ldr	r2, [r3, #0]
 800b29e:	68bb      	ldr	r3, [r7, #8]
 800b2a0:	011b      	lsls	r3, r3, #4
 800b2a2:	4413      	add	r3, r2
 800b2a4:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800b2a8:	681b      	ldr	r3, [r3, #0]
 800b2aa:	0a1a      	lsrs	r2, r3, #8
 800b2ac:	683b      	ldr	r3, [r7, #0]
 800b2ae:	3305      	adds	r3, #5
 800b2b0:	b2d2      	uxtb	r2, r2
 800b2b2:	701a      	strb	r2, [r3, #0]
    aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
 800b2b4:	68fb      	ldr	r3, [r7, #12]
 800b2b6:	681a      	ldr	r2, [r3, #0]
 800b2b8:	68bb      	ldr	r3, [r7, #8]
 800b2ba:	011b      	lsls	r3, r3, #4
 800b2bc:	4413      	add	r3, r2
 800b2be:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800b2c2:	681b      	ldr	r3, [r3, #0]
 800b2c4:	0c1a      	lsrs	r2, r3, #16
 800b2c6:	683b      	ldr	r3, [r7, #0]
 800b2c8:	3306      	adds	r3, #6
 800b2ca:	b2d2      	uxtb	r2, r2
 800b2cc:	701a      	strb	r2, [r3, #0]
    aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
 800b2ce:	68fb      	ldr	r3, [r7, #12]
 800b2d0:	681a      	ldr	r2, [r3, #0]
 800b2d2:	68bb      	ldr	r3, [r7, #8]
 800b2d4:	011b      	lsls	r3, r3, #4
 800b2d6:	4413      	add	r3, r2
 800b2d8:	f503 73de 	add.w	r3, r3, #444	@ 0x1bc
 800b2dc:	681b      	ldr	r3, [r3, #0]
 800b2de:	0e1a      	lsrs	r2, r3, #24
 800b2e0:	683b      	ldr	r3, [r7, #0]
 800b2e2:	3307      	adds	r3, #7
 800b2e4:	b2d2      	uxtb	r2, r2
 800b2e6:	701a      	strb	r2, [r3, #0]

    /* Release the FIFO */
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 800b2e8:	68bb      	ldr	r3, [r7, #8]
 800b2ea:	2b00      	cmp	r3, #0
 800b2ec:	d108      	bne.n	800b300 <HAL_CAN_GetRxMessage+0x216>
    {
      /* Release RX FIFO 0 */
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 800b2ee:	68fb      	ldr	r3, [r7, #12]
 800b2f0:	681b      	ldr	r3, [r3, #0]
 800b2f2:	68da      	ldr	r2, [r3, #12]
 800b2f4:	68fb      	ldr	r3, [r7, #12]
 800b2f6:	681b      	ldr	r3, [r3, #0]
 800b2f8:	f042 0220 	orr.w	r2, r2, #32
 800b2fc:	60da      	str	r2, [r3, #12]
 800b2fe:	e007      	b.n	800b310 <HAL_CAN_GetRxMessage+0x226>
    }
    else /* Rx element is assigned to Rx FIFO 1 */
    {
      /* Release RX FIFO 1 */
      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 800b300:	68fb      	ldr	r3, [r7, #12]
 800b302:	681b      	ldr	r3, [r3, #0]
 800b304:	691a      	ldr	r2, [r3, #16]
 800b306:	68fb      	ldr	r3, [r7, #12]
 800b308:	681b      	ldr	r3, [r3, #0]
 800b30a:	f042 0220 	orr.w	r2, r2, #32
 800b30e:	611a      	str	r2, [r3, #16]
    }

    /* Return function status */
    return HAL_OK;
 800b310:	2300      	movs	r3, #0
 800b312:	e006      	b.n	800b322 <HAL_CAN_GetRxMessage+0x238>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800b314:	68fb      	ldr	r3, [r7, #12]
 800b316:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b318:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
 800b31c:	68fb      	ldr	r3, [r7, #12]
 800b31e:	625a      	str	r2, [r3, #36]	@ 0x24

    return HAL_ERROR;
 800b320:	2301      	movs	r3, #1
  }
}
 800b322:	4618      	mov	r0, r3
 800b324:	371c      	adds	r7, #28
 800b326:	46bd      	mov	sp, r7
 800b328:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b32c:	4770      	bx	lr
	...

0800b330 <__NVIC_SetPriorityGrouping>:
{
 800b330:	b480      	push	{r7}
 800b332:	b085      	sub	sp, #20
 800b334:	af00      	add	r7, sp, #0
 800b336:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800b338:	687b      	ldr	r3, [r7, #4]
 800b33a:	f003 0307 	and.w	r3, r3, #7
 800b33e:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800b340:	4b0c      	ldr	r3, [pc, #48]	@ (800b374 <__NVIC_SetPriorityGrouping+0x44>)
 800b342:	68db      	ldr	r3, [r3, #12]
 800b344:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800b346:	68ba      	ldr	r2, [r7, #8]
 800b348:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 800b34c:	4013      	ands	r3, r2
 800b34e:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800b350:	68fb      	ldr	r3, [r7, #12]
 800b352:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800b354:	68bb      	ldr	r3, [r7, #8]
 800b356:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800b358:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800b35c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800b360:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800b362:	4a04      	ldr	r2, [pc, #16]	@ (800b374 <__NVIC_SetPriorityGrouping+0x44>)
 800b364:	68bb      	ldr	r3, [r7, #8]
 800b366:	60d3      	str	r3, [r2, #12]
}
 800b368:	bf00      	nop
 800b36a:	3714      	adds	r7, #20
 800b36c:	46bd      	mov	sp, r7
 800b36e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b372:	4770      	bx	lr
 800b374:	e000ed00 	.word	0xe000ed00

0800b378 <__NVIC_GetPriorityGrouping>:
{
 800b378:	b480      	push	{r7}
 800b37a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800b37c:	4b04      	ldr	r3, [pc, #16]	@ (800b390 <__NVIC_GetPriorityGrouping+0x18>)
 800b37e:	68db      	ldr	r3, [r3, #12]
 800b380:	0a1b      	lsrs	r3, r3, #8
 800b382:	f003 0307 	and.w	r3, r3, #7
}
 800b386:	4618      	mov	r0, r3
 800b388:	46bd      	mov	sp, r7
 800b38a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b38e:	4770      	bx	lr
 800b390:	e000ed00 	.word	0xe000ed00

0800b394 <__NVIC_SetPriority>:
{
 800b394:	b480      	push	{r7}
 800b396:	b083      	sub	sp, #12
 800b398:	af00      	add	r7, sp, #0
 800b39a:	4603      	mov	r3, r0
 800b39c:	6039      	str	r1, [r7, #0]
 800b39e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800b3a0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b3a4:	2b00      	cmp	r3, #0
 800b3a6:	db0a      	blt.n	800b3be <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b3a8:	683b      	ldr	r3, [r7, #0]
 800b3aa:	b2da      	uxtb	r2, r3
 800b3ac:	490c      	ldr	r1, [pc, #48]	@ (800b3e0 <__NVIC_SetPriority+0x4c>)
 800b3ae:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b3b2:	0112      	lsls	r2, r2, #4
 800b3b4:	b2d2      	uxtb	r2, r2
 800b3b6:	440b      	add	r3, r1
 800b3b8:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 800b3bc:	e00a      	b.n	800b3d4 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b3be:	683b      	ldr	r3, [r7, #0]
 800b3c0:	b2da      	uxtb	r2, r3
 800b3c2:	4908      	ldr	r1, [pc, #32]	@ (800b3e4 <__NVIC_SetPriority+0x50>)
 800b3c4:	79fb      	ldrb	r3, [r7, #7]
 800b3c6:	f003 030f 	and.w	r3, r3, #15
 800b3ca:	3b04      	subs	r3, #4
 800b3cc:	0112      	lsls	r2, r2, #4
 800b3ce:	b2d2      	uxtb	r2, r2
 800b3d0:	440b      	add	r3, r1
 800b3d2:	761a      	strb	r2, [r3, #24]
}
 800b3d4:	bf00      	nop
 800b3d6:	370c      	adds	r7, #12
 800b3d8:	46bd      	mov	sp, r7
 800b3da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3de:	4770      	bx	lr
 800b3e0:	e000e100 	.word	0xe000e100
 800b3e4:	e000ed00 	.word	0xe000ed00

0800b3e8 <NVIC_EncodePriority>:
{
 800b3e8:	b480      	push	{r7}
 800b3ea:	b089      	sub	sp, #36	@ 0x24
 800b3ec:	af00      	add	r7, sp, #0
 800b3ee:	60f8      	str	r0, [r7, #12]
 800b3f0:	60b9      	str	r1, [r7, #8]
 800b3f2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800b3f4:	68fb      	ldr	r3, [r7, #12]
 800b3f6:	f003 0307 	and.w	r3, r3, #7
 800b3fa:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800b3fc:	69fb      	ldr	r3, [r7, #28]
 800b3fe:	f1c3 0307 	rsb	r3, r3, #7
 800b402:	2b04      	cmp	r3, #4
 800b404:	bf28      	it	cs
 800b406:	2304      	movcs	r3, #4
 800b408:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800b40a:	69fb      	ldr	r3, [r7, #28]
 800b40c:	3304      	adds	r3, #4
 800b40e:	2b06      	cmp	r3, #6
 800b410:	d902      	bls.n	800b418 <NVIC_EncodePriority+0x30>
 800b412:	69fb      	ldr	r3, [r7, #28]
 800b414:	3b03      	subs	r3, #3
 800b416:	e000      	b.n	800b41a <NVIC_EncodePriority+0x32>
 800b418:	2300      	movs	r3, #0
 800b41a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b41c:	f04f 32ff 	mov.w	r2, #4294967295
 800b420:	69bb      	ldr	r3, [r7, #24]
 800b422:	fa02 f303 	lsl.w	r3, r2, r3
 800b426:	43da      	mvns	r2, r3
 800b428:	68bb      	ldr	r3, [r7, #8]
 800b42a:	401a      	ands	r2, r3
 800b42c:	697b      	ldr	r3, [r7, #20]
 800b42e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800b430:	f04f 31ff 	mov.w	r1, #4294967295
 800b434:	697b      	ldr	r3, [r7, #20]
 800b436:	fa01 f303 	lsl.w	r3, r1, r3
 800b43a:	43d9      	mvns	r1, r3
 800b43c:	687b      	ldr	r3, [r7, #4]
 800b43e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800b440:	4313      	orrs	r3, r2
}
 800b442:	4618      	mov	r0, r3
 800b444:	3724      	adds	r7, #36	@ 0x24
 800b446:	46bd      	mov	sp, r7
 800b448:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b44c:	4770      	bx	lr
	...

0800b450 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800b450:	b580      	push	{r7, lr}
 800b452:	b082      	sub	sp, #8
 800b454:	af00      	add	r7, sp, #0
 800b456:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800b458:	687b      	ldr	r3, [r7, #4]
 800b45a:	3b01      	subs	r3, #1
 800b45c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800b460:	d301      	bcc.n	800b466 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800b462:	2301      	movs	r3, #1
 800b464:	e00f      	b.n	800b486 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800b466:	4a0a      	ldr	r2, [pc, #40]	@ (800b490 <SysTick_Config+0x40>)
 800b468:	687b      	ldr	r3, [r7, #4]
 800b46a:	3b01      	subs	r3, #1
 800b46c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800b46e:	210f      	movs	r1, #15
 800b470:	f04f 30ff 	mov.w	r0, #4294967295
 800b474:	f7ff ff8e 	bl	800b394 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800b478:	4b05      	ldr	r3, [pc, #20]	@ (800b490 <SysTick_Config+0x40>)
 800b47a:	2200      	movs	r2, #0
 800b47c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800b47e:	4b04      	ldr	r3, [pc, #16]	@ (800b490 <SysTick_Config+0x40>)
 800b480:	2207      	movs	r2, #7
 800b482:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800b484:	2300      	movs	r3, #0
}
 800b486:	4618      	mov	r0, r3
 800b488:	3708      	adds	r7, #8
 800b48a:	46bd      	mov	sp, r7
 800b48c:	bd80      	pop	{r7, pc}
 800b48e:	bf00      	nop
 800b490:	e000e010 	.word	0xe000e010

0800b494 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800b494:	b580      	push	{r7, lr}
 800b496:	b082      	sub	sp, #8
 800b498:	af00      	add	r7, sp, #0
 800b49a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800b49c:	6878      	ldr	r0, [r7, #4]
 800b49e:	f7ff ff47 	bl	800b330 <__NVIC_SetPriorityGrouping>
}
 800b4a2:	bf00      	nop
 800b4a4:	3708      	adds	r7, #8
 800b4a6:	46bd      	mov	sp, r7
 800b4a8:	bd80      	pop	{r7, pc}

0800b4aa <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15 as described in the table CORTEX_NVIC_Priority_Table
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800b4aa:	b580      	push	{r7, lr}
 800b4ac:	b086      	sub	sp, #24
 800b4ae:	af00      	add	r7, sp, #0
 800b4b0:	4603      	mov	r3, r0
 800b4b2:	60b9      	str	r1, [r7, #8]
 800b4b4:	607a      	str	r2, [r7, #4]
 800b4b6:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 800b4b8:	2300      	movs	r3, #0
 800b4ba:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800b4bc:	f7ff ff5c 	bl	800b378 <__NVIC_GetPriorityGrouping>
 800b4c0:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800b4c2:	687a      	ldr	r2, [r7, #4]
 800b4c4:	68b9      	ldr	r1, [r7, #8]
 800b4c6:	6978      	ldr	r0, [r7, #20]
 800b4c8:	f7ff ff8e 	bl	800b3e8 <NVIC_EncodePriority>
 800b4cc:	4602      	mov	r2, r0
 800b4ce:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800b4d2:	4611      	mov	r1, r2
 800b4d4:	4618      	mov	r0, r3
 800b4d6:	f7ff ff5d 	bl	800b394 <__NVIC_SetPriority>
}
 800b4da:	bf00      	nop
 800b4dc:	3718      	adds	r7, #24
 800b4de:	46bd      	mov	sp, r7
 800b4e0:	bd80      	pop	{r7, pc}

0800b4e2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800b4e2:	b580      	push	{r7, lr}
 800b4e4:	b082      	sub	sp, #8
 800b4e6:	af00      	add	r7, sp, #0
 800b4e8:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800b4ea:	6878      	ldr	r0, [r7, #4]
 800b4ec:	f7ff ffb0 	bl	800b450 <SysTick_Config>
 800b4f0:	4603      	mov	r3, r0
}
 800b4f2:	4618      	mov	r0, r3
 800b4f4:	3708      	adds	r7, #8
 800b4f6:	46bd      	mov	sp, r7
 800b4f8:	bd80      	pop	{r7, pc}
	...

0800b4fc <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800b4fc:	b480      	push	{r7}
 800b4fe:	b087      	sub	sp, #28
 800b500:	af00      	add	r7, sp, #0
 800b502:	6078      	str	r0, [r7, #4]
 800b504:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 800b506:	2300      	movs	r3, #0
 800b508:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800b50a:	e160      	b.n	800b7ce <HAL_GPIO_Init+0x2d2>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800b50c:	683b      	ldr	r3, [r7, #0]
 800b50e:	681a      	ldr	r2, [r3, #0]
 800b510:	2101      	movs	r1, #1
 800b512:	697b      	ldr	r3, [r7, #20]
 800b514:	fa01 f303 	lsl.w	r3, r1, r3
 800b518:	4013      	ands	r3, r2
 800b51a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 800b51c:	68fb      	ldr	r3, [r7, #12]
 800b51e:	2b00      	cmp	r3, #0
 800b520:	f000 8152 	beq.w	800b7c8 <HAL_GPIO_Init+0x2cc>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800b524:	683b      	ldr	r3, [r7, #0]
 800b526:	685b      	ldr	r3, [r3, #4]
 800b528:	f003 0303 	and.w	r3, r3, #3
 800b52c:	2b01      	cmp	r3, #1
 800b52e:	d005      	beq.n	800b53c <HAL_GPIO_Init+0x40>
 800b530:	683b      	ldr	r3, [r7, #0]
 800b532:	685b      	ldr	r3, [r3, #4]
 800b534:	f003 0303 	and.w	r3, r3, #3
 800b538:	2b02      	cmp	r3, #2
 800b53a:	d130      	bne.n	800b59e <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800b53c:	687b      	ldr	r3, [r7, #4]
 800b53e:	689b      	ldr	r3, [r3, #8]
 800b540:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 800b542:	697b      	ldr	r3, [r7, #20]
 800b544:	005b      	lsls	r3, r3, #1
 800b546:	2203      	movs	r2, #3
 800b548:	fa02 f303 	lsl.w	r3, r2, r3
 800b54c:	43db      	mvns	r3, r3
 800b54e:	693a      	ldr	r2, [r7, #16]
 800b550:	4013      	ands	r3, r2
 800b552:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 800b554:	683b      	ldr	r3, [r7, #0]
 800b556:	68da      	ldr	r2, [r3, #12]
 800b558:	697b      	ldr	r3, [r7, #20]
 800b55a:	005b      	lsls	r3, r3, #1
 800b55c:	fa02 f303 	lsl.w	r3, r2, r3
 800b560:	693a      	ldr	r2, [r7, #16]
 800b562:	4313      	orrs	r3, r2
 800b564:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800b566:	687b      	ldr	r3, [r7, #4]
 800b568:	693a      	ldr	r2, [r7, #16]
 800b56a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800b56c:	687b      	ldr	r3, [r7, #4]
 800b56e:	685b      	ldr	r3, [r3, #4]
 800b570:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800b572:	2201      	movs	r2, #1
 800b574:	697b      	ldr	r3, [r7, #20]
 800b576:	fa02 f303 	lsl.w	r3, r2, r3
 800b57a:	43db      	mvns	r3, r3
 800b57c:	693a      	ldr	r2, [r7, #16]
 800b57e:	4013      	ands	r3, r2
 800b580:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800b582:	683b      	ldr	r3, [r7, #0]
 800b584:	685b      	ldr	r3, [r3, #4]
 800b586:	091b      	lsrs	r3, r3, #4
 800b588:	f003 0201 	and.w	r2, r3, #1
 800b58c:	697b      	ldr	r3, [r7, #20]
 800b58e:	fa02 f303 	lsl.w	r3, r2, r3
 800b592:	693a      	ldr	r2, [r7, #16]
 800b594:	4313      	orrs	r3, r2
 800b596:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800b598:	687b      	ldr	r3, [r7, #4]
 800b59a:	693a      	ldr	r2, [r7, #16]
 800b59c:	605a      	str	r2, [r3, #4]
      }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800b59e:	683b      	ldr	r3, [r7, #0]
 800b5a0:	685b      	ldr	r3, [r3, #4]
 800b5a2:	f003 0303 	and.w	r3, r3, #3
 800b5a6:	2b03      	cmp	r3, #3
 800b5a8:	d017      	beq.n	800b5da <HAL_GPIO_Init+0xde>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800b5aa:	687b      	ldr	r3, [r7, #4]
 800b5ac:	68db      	ldr	r3, [r3, #12]
 800b5ae:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 800b5b0:	697b      	ldr	r3, [r7, #20]
 800b5b2:	005b      	lsls	r3, r3, #1
 800b5b4:	2203      	movs	r2, #3
 800b5b6:	fa02 f303 	lsl.w	r3, r2, r3
 800b5ba:	43db      	mvns	r3, r3
 800b5bc:	693a      	ldr	r2, [r7, #16]
 800b5be:	4013      	ands	r3, r2
 800b5c0:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2u));
 800b5c2:	683b      	ldr	r3, [r7, #0]
 800b5c4:	689a      	ldr	r2, [r3, #8]
 800b5c6:	697b      	ldr	r3, [r7, #20]
 800b5c8:	005b      	lsls	r3, r3, #1
 800b5ca:	fa02 f303 	lsl.w	r3, r2, r3
 800b5ce:	693a      	ldr	r2, [r7, #16]
 800b5d0:	4313      	orrs	r3, r2
 800b5d2:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 800b5d4:	687b      	ldr	r3, [r7, #4]
 800b5d6:	693a      	ldr	r2, [r7, #16]
 800b5d8:	60da      	str	r2, [r3, #12]
      }

      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800b5da:	683b      	ldr	r3, [r7, #0]
 800b5dc:	685b      	ldr	r3, [r3, #4]
 800b5de:	f003 0303 	and.w	r3, r3, #3
 800b5e2:	2b02      	cmp	r3, #2
 800b5e4:	d123      	bne.n	800b62e <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 800b5e6:	697b      	ldr	r3, [r7, #20]
 800b5e8:	08da      	lsrs	r2, r3, #3
 800b5ea:	687b      	ldr	r3, [r7, #4]
 800b5ec:	3208      	adds	r2, #8
 800b5ee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b5f2:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800b5f4:	697b      	ldr	r3, [r7, #20]
 800b5f6:	f003 0307 	and.w	r3, r3, #7
 800b5fa:	009b      	lsls	r3, r3, #2
 800b5fc:	220f      	movs	r2, #15
 800b5fe:	fa02 f303 	lsl.w	r3, r2, r3
 800b602:	43db      	mvns	r3, r3
 800b604:	693a      	ldr	r2, [r7, #16]
 800b606:	4013      	ands	r3, r2
 800b608:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 800b60a:	683b      	ldr	r3, [r7, #0]
 800b60c:	691a      	ldr	r2, [r3, #16]
 800b60e:	697b      	ldr	r3, [r7, #20]
 800b610:	f003 0307 	and.w	r3, r3, #7
 800b614:	009b      	lsls	r3, r3, #2
 800b616:	fa02 f303 	lsl.w	r3, r2, r3
 800b61a:	693a      	ldr	r2, [r7, #16]
 800b61c:	4313      	orrs	r3, r2
 800b61e:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 800b620:	697b      	ldr	r3, [r7, #20]
 800b622:	08da      	lsrs	r2, r3, #3
 800b624:	687b      	ldr	r3, [r7, #4]
 800b626:	3208      	adds	r2, #8
 800b628:	6939      	ldr	r1, [r7, #16]
 800b62a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800b62e:	687b      	ldr	r3, [r7, #4]
 800b630:	681b      	ldr	r3, [r3, #0]
 800b632:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 800b634:	697b      	ldr	r3, [r7, #20]
 800b636:	005b      	lsls	r3, r3, #1
 800b638:	2203      	movs	r2, #3
 800b63a:	fa02 f303 	lsl.w	r3, r2, r3
 800b63e:	43db      	mvns	r3, r3
 800b640:	693a      	ldr	r2, [r7, #16]
 800b642:	4013      	ands	r3, r2
 800b644:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800b646:	683b      	ldr	r3, [r7, #0]
 800b648:	685b      	ldr	r3, [r3, #4]
 800b64a:	f003 0203 	and.w	r2, r3, #3
 800b64e:	697b      	ldr	r3, [r7, #20]
 800b650:	005b      	lsls	r3, r3, #1
 800b652:	fa02 f303 	lsl.w	r3, r2, r3
 800b656:	693a      	ldr	r2, [r7, #16]
 800b658:	4313      	orrs	r3, r2
 800b65a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800b65c:	687b      	ldr	r3, [r7, #4]
 800b65e:	693a      	ldr	r2, [r7, #16]
 800b660:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800b662:	683b      	ldr	r3, [r7, #0]
 800b664:	685b      	ldr	r3, [r3, #4]
 800b666:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 800b66a:	2b00      	cmp	r3, #0
 800b66c:	f000 80ac 	beq.w	800b7c8 <HAL_GPIO_Init+0x2cc>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800b670:	4b5e      	ldr	r3, [pc, #376]	@ (800b7ec <HAL_GPIO_Init+0x2f0>)
 800b672:	699b      	ldr	r3, [r3, #24]
 800b674:	4a5d      	ldr	r2, [pc, #372]	@ (800b7ec <HAL_GPIO_Init+0x2f0>)
 800b676:	f043 0301 	orr.w	r3, r3, #1
 800b67a:	6193      	str	r3, [r2, #24]
 800b67c:	4b5b      	ldr	r3, [pc, #364]	@ (800b7ec <HAL_GPIO_Init+0x2f0>)
 800b67e:	699b      	ldr	r3, [r3, #24]
 800b680:	f003 0301 	and.w	r3, r3, #1
 800b684:	60bb      	str	r3, [r7, #8]
 800b686:	68bb      	ldr	r3, [r7, #8]

        temp = SYSCFG->EXTICR[position >> 2u];
 800b688:	4a59      	ldr	r2, [pc, #356]	@ (800b7f0 <HAL_GPIO_Init+0x2f4>)
 800b68a:	697b      	ldr	r3, [r7, #20]
 800b68c:	089b      	lsrs	r3, r3, #2
 800b68e:	3302      	adds	r3, #2
 800b690:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b694:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800b696:	697b      	ldr	r3, [r7, #20]
 800b698:	f003 0303 	and.w	r3, r3, #3
 800b69c:	009b      	lsls	r3, r3, #2
 800b69e:	220f      	movs	r2, #15
 800b6a0:	fa02 f303 	lsl.w	r3, r2, r3
 800b6a4:	43db      	mvns	r3, r3
 800b6a6:	693a      	ldr	r2, [r7, #16]
 800b6a8:	4013      	ands	r3, r2
 800b6aa:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800b6ac:	687b      	ldr	r3, [r7, #4]
 800b6ae:	f1b3 4f90 	cmp.w	r3, #1207959552	@ 0x48000000
 800b6b2:	d025      	beq.n	800b700 <HAL_GPIO_Init+0x204>
 800b6b4:	687b      	ldr	r3, [r7, #4]
 800b6b6:	4a4f      	ldr	r2, [pc, #316]	@ (800b7f4 <HAL_GPIO_Init+0x2f8>)
 800b6b8:	4293      	cmp	r3, r2
 800b6ba:	d01f      	beq.n	800b6fc <HAL_GPIO_Init+0x200>
 800b6bc:	687b      	ldr	r3, [r7, #4]
 800b6be:	4a4e      	ldr	r2, [pc, #312]	@ (800b7f8 <HAL_GPIO_Init+0x2fc>)
 800b6c0:	4293      	cmp	r3, r2
 800b6c2:	d019      	beq.n	800b6f8 <HAL_GPIO_Init+0x1fc>
 800b6c4:	687b      	ldr	r3, [r7, #4]
 800b6c6:	4a4d      	ldr	r2, [pc, #308]	@ (800b7fc <HAL_GPIO_Init+0x300>)
 800b6c8:	4293      	cmp	r3, r2
 800b6ca:	d013      	beq.n	800b6f4 <HAL_GPIO_Init+0x1f8>
 800b6cc:	687b      	ldr	r3, [r7, #4]
 800b6ce:	4a4c      	ldr	r2, [pc, #304]	@ (800b800 <HAL_GPIO_Init+0x304>)
 800b6d0:	4293      	cmp	r3, r2
 800b6d2:	d00d      	beq.n	800b6f0 <HAL_GPIO_Init+0x1f4>
 800b6d4:	687b      	ldr	r3, [r7, #4]
 800b6d6:	4a4b      	ldr	r2, [pc, #300]	@ (800b804 <HAL_GPIO_Init+0x308>)
 800b6d8:	4293      	cmp	r3, r2
 800b6da:	d007      	beq.n	800b6ec <HAL_GPIO_Init+0x1f0>
 800b6dc:	687b      	ldr	r3, [r7, #4]
 800b6de:	4a4a      	ldr	r2, [pc, #296]	@ (800b808 <HAL_GPIO_Init+0x30c>)
 800b6e0:	4293      	cmp	r3, r2
 800b6e2:	d101      	bne.n	800b6e8 <HAL_GPIO_Init+0x1ec>
 800b6e4:	2306      	movs	r3, #6
 800b6e6:	e00c      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b6e8:	2307      	movs	r3, #7
 800b6ea:	e00a      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b6ec:	2305      	movs	r3, #5
 800b6ee:	e008      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b6f0:	2304      	movs	r3, #4
 800b6f2:	e006      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b6f4:	2303      	movs	r3, #3
 800b6f6:	e004      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b6f8:	2302      	movs	r3, #2
 800b6fa:	e002      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b6fc:	2301      	movs	r3, #1
 800b6fe:	e000      	b.n	800b702 <HAL_GPIO_Init+0x206>
 800b700:	2300      	movs	r3, #0
 800b702:	697a      	ldr	r2, [r7, #20]
 800b704:	f002 0203 	and.w	r2, r2, #3
 800b708:	0092      	lsls	r2, r2, #2
 800b70a:	4093      	lsls	r3, r2
 800b70c:	693a      	ldr	r2, [r7, #16]
 800b70e:	4313      	orrs	r3, r2
 800b710:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 800b712:	4937      	ldr	r1, [pc, #220]	@ (800b7f0 <HAL_GPIO_Init+0x2f4>)
 800b714:	697b      	ldr	r3, [r7, #20]
 800b716:	089b      	lsrs	r3, r3, #2
 800b718:	3302      	adds	r3, #2
 800b71a:	693a      	ldr	r2, [r7, #16]
 800b71c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800b720:	4b3a      	ldr	r3, [pc, #232]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b722:	689b      	ldr	r3, [r3, #8]
 800b724:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b726:	68fb      	ldr	r3, [r7, #12]
 800b728:	43db      	mvns	r3, r3
 800b72a:	693a      	ldr	r2, [r7, #16]
 800b72c:	4013      	ands	r3, r2
 800b72e:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800b730:	683b      	ldr	r3, [r7, #0]
 800b732:	685b      	ldr	r3, [r3, #4]
 800b734:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800b738:	2b00      	cmp	r3, #0
 800b73a:	d003      	beq.n	800b744 <HAL_GPIO_Init+0x248>
        {
          temp |= iocurrent;
 800b73c:	693a      	ldr	r2, [r7, #16]
 800b73e:	68fb      	ldr	r3, [r7, #12]
 800b740:	4313      	orrs	r3, r2
 800b742:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800b744:	4a31      	ldr	r2, [pc, #196]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b746:	693b      	ldr	r3, [r7, #16]
 800b748:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800b74a:	4b30      	ldr	r3, [pc, #192]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b74c:	68db      	ldr	r3, [r3, #12]
 800b74e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b750:	68fb      	ldr	r3, [r7, #12]
 800b752:	43db      	mvns	r3, r3
 800b754:	693a      	ldr	r2, [r7, #16]
 800b756:	4013      	ands	r3, r2
 800b758:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800b75a:	683b      	ldr	r3, [r7, #0]
 800b75c:	685b      	ldr	r3, [r3, #4]
 800b75e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800b762:	2b00      	cmp	r3, #0
 800b764:	d003      	beq.n	800b76e <HAL_GPIO_Init+0x272>
        {
          temp |= iocurrent;
 800b766:	693a      	ldr	r2, [r7, #16]
 800b768:	68fb      	ldr	r3, [r7, #12]
 800b76a:	4313      	orrs	r3, r2
 800b76c:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 800b76e:	4a27      	ldr	r2, [pc, #156]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b770:	693b      	ldr	r3, [r7, #16]
 800b772:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800b774:	4b25      	ldr	r3, [pc, #148]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b776:	685b      	ldr	r3, [r3, #4]
 800b778:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b77a:	68fb      	ldr	r3, [r7, #12]
 800b77c:	43db      	mvns	r3, r3
 800b77e:	693a      	ldr	r2, [r7, #16]
 800b780:	4013      	ands	r3, r2
 800b782:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 800b784:	683b      	ldr	r3, [r7, #0]
 800b786:	685b      	ldr	r3, [r3, #4]
 800b788:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800b78c:	2b00      	cmp	r3, #0
 800b78e:	d003      	beq.n	800b798 <HAL_GPIO_Init+0x29c>
        {
          temp |= iocurrent;
 800b790:	693a      	ldr	r2, [r7, #16]
 800b792:	68fb      	ldr	r3, [r7, #12]
 800b794:	4313      	orrs	r3, r2
 800b796:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 800b798:	4a1c      	ldr	r2, [pc, #112]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b79a:	693b      	ldr	r3, [r7, #16]
 800b79c:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800b79e:	4b1b      	ldr	r3, [pc, #108]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b7a0:	681b      	ldr	r3, [r3, #0]
 800b7a2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800b7a4:	68fb      	ldr	r3, [r7, #12]
 800b7a6:	43db      	mvns	r3, r3
 800b7a8:	693a      	ldr	r2, [r7, #16]
 800b7aa:	4013      	ands	r3, r2
 800b7ac:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800b7ae:	683b      	ldr	r3, [r7, #0]
 800b7b0:	685b      	ldr	r3, [r3, #4]
 800b7b2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800b7b6:	2b00      	cmp	r3, #0
 800b7b8:	d003      	beq.n	800b7c2 <HAL_GPIO_Init+0x2c6>
        {
          temp |= iocurrent;
 800b7ba:	693a      	ldr	r2, [r7, #16]
 800b7bc:	68fb      	ldr	r3, [r7, #12]
 800b7be:	4313      	orrs	r3, r2
 800b7c0:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 800b7c2:	4a12      	ldr	r2, [pc, #72]	@ (800b80c <HAL_GPIO_Init+0x310>)
 800b7c4:	693b      	ldr	r3, [r7, #16]
 800b7c6:	6013      	str	r3, [r2, #0]
      }
    }

    position++;
 800b7c8:	697b      	ldr	r3, [r7, #20]
 800b7ca:	3301      	adds	r3, #1
 800b7cc:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800b7ce:	683b      	ldr	r3, [r7, #0]
 800b7d0:	681a      	ldr	r2, [r3, #0]
 800b7d2:	697b      	ldr	r3, [r7, #20]
 800b7d4:	fa22 f303 	lsr.w	r3, r2, r3
 800b7d8:	2b00      	cmp	r3, #0
 800b7da:	f47f ae97 	bne.w	800b50c <HAL_GPIO_Init+0x10>
  }
}
 800b7de:	bf00      	nop
 800b7e0:	bf00      	nop
 800b7e2:	371c      	adds	r7, #28
 800b7e4:	46bd      	mov	sp, r7
 800b7e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b7ea:	4770      	bx	lr
 800b7ec:	40021000 	.word	0x40021000
 800b7f0:	40010000 	.word	0x40010000
 800b7f4:	48000400 	.word	0x48000400
 800b7f8:	48000800 	.word	0x48000800
 800b7fc:	48000c00 	.word	0x48000c00
 800b800:	48001000 	.word	0x48001000
 800b804:	48001400 	.word	0x48001400
 800b808:	48001800 	.word	0x48001800
 800b80c:	40010400 	.word	0x40010400

0800b810 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800b810:	b480      	push	{r7}
 800b812:	b083      	sub	sp, #12
 800b814:	af00      	add	r7, sp, #0
 800b816:	6078      	str	r0, [r7, #4]
 800b818:	460b      	mov	r3, r1
 800b81a:	807b      	strh	r3, [r7, #2]
 800b81c:	4613      	mov	r3, r2
 800b81e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800b820:	787b      	ldrb	r3, [r7, #1]
 800b822:	2b00      	cmp	r3, #0
 800b824:	d003      	beq.n	800b82e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800b826:	887a      	ldrh	r2, [r7, #2]
 800b828:	687b      	ldr	r3, [r7, #4]
 800b82a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800b82c:	e002      	b.n	800b834 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800b82e:	887a      	ldrh	r2, [r7, #2]
 800b830:	687b      	ldr	r3, [r7, #4]
 800b832:	629a      	str	r2, [r3, #40]	@ 0x28
}
 800b834:	bf00      	nop
 800b836:	370c      	adds	r7, #12
 800b838:	46bd      	mov	sp, r7
 800b83a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b83e:	4770      	bx	lr

0800b840 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800b840:	b580      	push	{r7, lr}
 800b842:	f5ad 7d02 	sub.w	sp, sp, #520	@ 0x208
 800b846:	af00      	add	r7, sp, #0
 800b848:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b84c:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b850:	6018      	str	r0, [r3, #0]
#if defined(RCC_CFGR_PLLSRC_HSI_PREDIV)
  uint32_t pll_config2;
#endif /* RCC_CFGR_PLLSRC_HSI_PREDIV */

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800b852:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b856:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b85a:	681b      	ldr	r3, [r3, #0]
 800b85c:	2b00      	cmp	r3, #0
 800b85e:	d102      	bne.n	800b866 <HAL_RCC_OscConfig+0x26>
  {
    return HAL_ERROR;
 800b860:	2301      	movs	r3, #1
 800b862:	f001 b80a 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800b866:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b86a:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b86e:	681b      	ldr	r3, [r3, #0]
 800b870:	681b      	ldr	r3, [r3, #0]
 800b872:	f003 0301 	and.w	r3, r3, #1
 800b876:	2b00      	cmp	r3, #0
 800b878:	f000 8161 	beq.w	800bb3e <HAL_RCC_OscConfig+0x2fe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800b87c:	4bae      	ldr	r3, [pc, #696]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b87e:	685b      	ldr	r3, [r3, #4]
 800b880:	f003 030c 	and.w	r3, r3, #12
 800b884:	2b04      	cmp	r3, #4
 800b886:	d00c      	beq.n	800b8a2 <HAL_RCC_OscConfig+0x62>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800b888:	4bab      	ldr	r3, [pc, #684]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b88a:	685b      	ldr	r3, [r3, #4]
 800b88c:	f003 030c 	and.w	r3, r3, #12
 800b890:	2b08      	cmp	r3, #8
 800b892:	d157      	bne.n	800b944 <HAL_RCC_OscConfig+0x104>
 800b894:	4ba8      	ldr	r3, [pc, #672]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b896:	685b      	ldr	r3, [r3, #4]
 800b898:	f403 33c0 	and.w	r3, r3, #98304	@ 0x18000
 800b89c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800b8a0:	d150      	bne.n	800b944 <HAL_RCC_OscConfig+0x104>
 800b8a2:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800b8a6:	f8c7 31f4 	str.w	r3, [r7, #500]	@ 0x1f4
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800b8aa:	f8d7 31f4 	ldr.w	r3, [r7, #500]	@ 0x1f4
 800b8ae:	fa93 f3a3 	rbit	r3, r3
 800b8b2:	f8c7 31f0 	str.w	r3, [r7, #496]	@ 0x1f0
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 800b8b6:	f8d7 31f0 	ldr.w	r3, [r7, #496]	@ 0x1f0
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800b8ba:	fab3 f383 	clz	r3, r3
 800b8be:	b2db      	uxtb	r3, r3
 800b8c0:	2b3f      	cmp	r3, #63	@ 0x3f
 800b8c2:	d802      	bhi.n	800b8ca <HAL_RCC_OscConfig+0x8a>
 800b8c4:	4b9c      	ldr	r3, [pc, #624]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b8c6:	681b      	ldr	r3, [r3, #0]
 800b8c8:	e015      	b.n	800b8f6 <HAL_RCC_OscConfig+0xb6>
 800b8ca:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800b8ce:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800b8d2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	@ 0x1ec
 800b8d6:	fa93 f3a3 	rbit	r3, r3
 800b8da:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
 800b8de:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800b8e2:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
 800b8e6:	f8d7 31e4 	ldr.w	r3, [r7, #484]	@ 0x1e4
 800b8ea:	fa93 f3a3 	rbit	r3, r3
 800b8ee:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
 800b8f2:	4b91      	ldr	r3, [pc, #580]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b8f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b8f6:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800b8fa:	f8c7 21dc 	str.w	r2, [r7, #476]	@ 0x1dc
 800b8fe:	f8d7 21dc 	ldr.w	r2, [r7, #476]	@ 0x1dc
 800b902:	fa92 f2a2 	rbit	r2, r2
 800b906:	f8c7 21d8 	str.w	r2, [r7, #472]	@ 0x1d8
  return result;
 800b90a:	f8d7 21d8 	ldr.w	r2, [r7, #472]	@ 0x1d8
 800b90e:	fab2 f282 	clz	r2, r2
 800b912:	b2d2      	uxtb	r2, r2
 800b914:	f042 0220 	orr.w	r2, r2, #32
 800b918:	b2d2      	uxtb	r2, r2
 800b91a:	f002 021f 	and.w	r2, r2, #31
 800b91e:	2101      	movs	r1, #1
 800b920:	fa01 f202 	lsl.w	r2, r1, r2
 800b924:	4013      	ands	r3, r2
 800b926:	2b00      	cmp	r3, #0
 800b928:	f000 8108 	beq.w	800bb3c <HAL_RCC_OscConfig+0x2fc>
 800b92c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b930:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b934:	681b      	ldr	r3, [r3, #0]
 800b936:	685b      	ldr	r3, [r3, #4]
 800b938:	2b00      	cmp	r3, #0
 800b93a:	f040 80ff 	bne.w	800bb3c <HAL_RCC_OscConfig+0x2fc>
      {
        return HAL_ERROR;
 800b93e:	2301      	movs	r3, #1
 800b940:	f000 bf9b 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800b944:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b948:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b94c:	681b      	ldr	r3, [r3, #0]
 800b94e:	685b      	ldr	r3, [r3, #4]
 800b950:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800b954:	d106      	bne.n	800b964 <HAL_RCC_OscConfig+0x124>
 800b956:	4b78      	ldr	r3, [pc, #480]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b958:	681b      	ldr	r3, [r3, #0]
 800b95a:	4a77      	ldr	r2, [pc, #476]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b95c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800b960:	6013      	str	r3, [r2, #0]
 800b962:	e036      	b.n	800b9d2 <HAL_RCC_OscConfig+0x192>
 800b964:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b968:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b96c:	681b      	ldr	r3, [r3, #0]
 800b96e:	685b      	ldr	r3, [r3, #4]
 800b970:	2b00      	cmp	r3, #0
 800b972:	d10c      	bne.n	800b98e <HAL_RCC_OscConfig+0x14e>
 800b974:	4b70      	ldr	r3, [pc, #448]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b976:	681b      	ldr	r3, [r3, #0]
 800b978:	4a6f      	ldr	r2, [pc, #444]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b97a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800b97e:	6013      	str	r3, [r2, #0]
 800b980:	4b6d      	ldr	r3, [pc, #436]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b982:	681b      	ldr	r3, [r3, #0]
 800b984:	4a6c      	ldr	r2, [pc, #432]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b986:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800b98a:	6013      	str	r3, [r2, #0]
 800b98c:	e021      	b.n	800b9d2 <HAL_RCC_OscConfig+0x192>
 800b98e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b992:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b996:	681b      	ldr	r3, [r3, #0]
 800b998:	685b      	ldr	r3, [r3, #4]
 800b99a:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800b99e:	d10c      	bne.n	800b9ba <HAL_RCC_OscConfig+0x17a>
 800b9a0:	4b65      	ldr	r3, [pc, #404]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9a2:	681b      	ldr	r3, [r3, #0]
 800b9a4:	4a64      	ldr	r2, [pc, #400]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9a6:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800b9aa:	6013      	str	r3, [r2, #0]
 800b9ac:	4b62      	ldr	r3, [pc, #392]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9ae:	681b      	ldr	r3, [r3, #0]
 800b9b0:	4a61      	ldr	r2, [pc, #388]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9b2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800b9b6:	6013      	str	r3, [r2, #0]
 800b9b8:	e00b      	b.n	800b9d2 <HAL_RCC_OscConfig+0x192>
 800b9ba:	4b5f      	ldr	r3, [pc, #380]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9bc:	681b      	ldr	r3, [r3, #0]
 800b9be:	4a5e      	ldr	r2, [pc, #376]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9c0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800b9c4:	6013      	str	r3, [r2, #0]
 800b9c6:	4b5c      	ldr	r3, [pc, #368]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9c8:	681b      	ldr	r3, [r3, #0]
 800b9ca:	4a5b      	ldr	r2, [pc, #364]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800b9cc:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800b9d0:	6013      	str	r3, [r2, #0]
      /* Configure the HSE predivision factor --------------------------------*/
      __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
#endif /* RCC_CFGR_PLLSRC_HSI_DIV2 */

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800b9d2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800b9d6:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800b9da:	681b      	ldr	r3, [r3, #0]
 800b9dc:	685b      	ldr	r3, [r3, #4]
 800b9de:	2b00      	cmp	r3, #0
 800b9e0:	d054      	beq.n	800ba8c <HAL_RCC_OscConfig+0x24c>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800b9e2:	f7ff f89d 	bl	800ab20 <HAL_GetTick>
 800b9e6:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b9ea:	e00a      	b.n	800ba02 <HAL_RCC_OscConfig+0x1c2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800b9ec:	f7ff f898 	bl	800ab20 <HAL_GetTick>
 800b9f0:	4602      	mov	r2, r0
 800b9f2:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800b9f6:	1ad3      	subs	r3, r2, r3
 800b9f8:	2b64      	cmp	r3, #100	@ 0x64
 800b9fa:	d902      	bls.n	800ba02 <HAL_RCC_OscConfig+0x1c2>
          {
            return HAL_TIMEOUT;
 800b9fc:	2303      	movs	r3, #3
 800b9fe:	f000 bf3c 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
 800ba02:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800ba06:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800ba0a:	f8d7 31d4 	ldr.w	r3, [r7, #468]	@ 0x1d4
 800ba0e:	fa93 f3a3 	rbit	r3, r3
 800ba12:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0
  return result;
 800ba16:	f8d7 31d0 	ldr.w	r3, [r7, #464]	@ 0x1d0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800ba1a:	fab3 f383 	clz	r3, r3
 800ba1e:	b2db      	uxtb	r3, r3
 800ba20:	2b3f      	cmp	r3, #63	@ 0x3f
 800ba22:	d802      	bhi.n	800ba2a <HAL_RCC_OscConfig+0x1ea>
 800ba24:	4b44      	ldr	r3, [pc, #272]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800ba26:	681b      	ldr	r3, [r3, #0]
 800ba28:	e015      	b.n	800ba56 <HAL_RCC_OscConfig+0x216>
 800ba2a:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800ba2e:	f8c7 31cc 	str.w	r3, [r7, #460]	@ 0x1cc
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800ba32:	f8d7 31cc 	ldr.w	r3, [r7, #460]	@ 0x1cc
 800ba36:	fa93 f3a3 	rbit	r3, r3
 800ba3a:	f8c7 31c8 	str.w	r3, [r7, #456]	@ 0x1c8
 800ba3e:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800ba42:	f8c7 31c4 	str.w	r3, [r7, #452]	@ 0x1c4
 800ba46:	f8d7 31c4 	ldr.w	r3, [r7, #452]	@ 0x1c4
 800ba4a:	fa93 f3a3 	rbit	r3, r3
 800ba4e:	f8c7 31c0 	str.w	r3, [r7, #448]	@ 0x1c0
 800ba52:	4b39      	ldr	r3, [pc, #228]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800ba54:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ba56:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800ba5a:	f8c7 21bc 	str.w	r2, [r7, #444]	@ 0x1bc
 800ba5e:	f8d7 21bc 	ldr.w	r2, [r7, #444]	@ 0x1bc
 800ba62:	fa92 f2a2 	rbit	r2, r2
 800ba66:	f8c7 21b8 	str.w	r2, [r7, #440]	@ 0x1b8
  return result;
 800ba6a:	f8d7 21b8 	ldr.w	r2, [r7, #440]	@ 0x1b8
 800ba6e:	fab2 f282 	clz	r2, r2
 800ba72:	b2d2      	uxtb	r2, r2
 800ba74:	f042 0220 	orr.w	r2, r2, #32
 800ba78:	b2d2      	uxtb	r2, r2
 800ba7a:	f002 021f 	and.w	r2, r2, #31
 800ba7e:	2101      	movs	r1, #1
 800ba80:	fa01 f202 	lsl.w	r2, r1, r2
 800ba84:	4013      	ands	r3, r2
 800ba86:	2b00      	cmp	r3, #0
 800ba88:	d0b0      	beq.n	800b9ec <HAL_RCC_OscConfig+0x1ac>
 800ba8a:	e058      	b.n	800bb3e <HAL_RCC_OscConfig+0x2fe>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800ba8c:	f7ff f848 	bl	800ab20 <HAL_GetTick>
 800ba90:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800ba94:	e00a      	b.n	800baac <HAL_RCC_OscConfig+0x26c>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800ba96:	f7ff f843 	bl	800ab20 <HAL_GetTick>
 800ba9a:	4602      	mov	r2, r0
 800ba9c:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800baa0:	1ad3      	subs	r3, r2, r3
 800baa2:	2b64      	cmp	r3, #100	@ 0x64
 800baa4:	d902      	bls.n	800baac <HAL_RCC_OscConfig+0x26c>
          {
            return HAL_TIMEOUT;
 800baa6:	2303      	movs	r3, #3
 800baa8:	f000 bee7 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
 800baac:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800bab0:	f8c7 31b4 	str.w	r3, [r7, #436]	@ 0x1b4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bab4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
 800bab8:	fa93 f3a3 	rbit	r3, r3
 800babc:	f8c7 31b0 	str.w	r3, [r7, #432]	@ 0x1b0
  return result;
 800bac0:	f8d7 31b0 	ldr.w	r3, [r7, #432]	@ 0x1b0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800bac4:	fab3 f383 	clz	r3, r3
 800bac8:	b2db      	uxtb	r3, r3
 800baca:	2b3f      	cmp	r3, #63	@ 0x3f
 800bacc:	d802      	bhi.n	800bad4 <HAL_RCC_OscConfig+0x294>
 800bace:	4b1a      	ldr	r3, [pc, #104]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800bad0:	681b      	ldr	r3, [r3, #0]
 800bad2:	e015      	b.n	800bb00 <HAL_RCC_OscConfig+0x2c0>
 800bad4:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800bad8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800badc:	f8d7 31ac 	ldr.w	r3, [r7, #428]	@ 0x1ac
 800bae0:	fa93 f3a3 	rbit	r3, r3
 800bae4:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
 800bae8:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800baec:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
 800baf0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	@ 0x1a4
 800baf4:	fa93 f3a3 	rbit	r3, r3
 800baf8:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
 800bafc:	4b0e      	ldr	r3, [pc, #56]	@ (800bb38 <HAL_RCC_OscConfig+0x2f8>)
 800bafe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bb00:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800bb04:	f8c7 219c 	str.w	r2, [r7, #412]	@ 0x19c
 800bb08:	f8d7 219c 	ldr.w	r2, [r7, #412]	@ 0x19c
 800bb0c:	fa92 f2a2 	rbit	r2, r2
 800bb10:	f8c7 2198 	str.w	r2, [r7, #408]	@ 0x198
  return result;
 800bb14:	f8d7 2198 	ldr.w	r2, [r7, #408]	@ 0x198
 800bb18:	fab2 f282 	clz	r2, r2
 800bb1c:	b2d2      	uxtb	r2, r2
 800bb1e:	f042 0220 	orr.w	r2, r2, #32
 800bb22:	b2d2      	uxtb	r2, r2
 800bb24:	f002 021f 	and.w	r2, r2, #31
 800bb28:	2101      	movs	r1, #1
 800bb2a:	fa01 f202 	lsl.w	r2, r1, r2
 800bb2e:	4013      	ands	r3, r2
 800bb30:	2b00      	cmp	r3, #0
 800bb32:	d1b0      	bne.n	800ba96 <HAL_RCC_OscConfig+0x256>
 800bb34:	e003      	b.n	800bb3e <HAL_RCC_OscConfig+0x2fe>
 800bb36:	bf00      	nop
 800bb38:	40021000 	.word	0x40021000
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800bb3c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800bb3e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bb42:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800bb46:	681b      	ldr	r3, [r3, #0]
 800bb48:	681b      	ldr	r3, [r3, #0]
 800bb4a:	f003 0302 	and.w	r3, r3, #2
 800bb4e:	2b00      	cmp	r3, #0
 800bb50:	f000 816d 	beq.w	800be2e <HAL_RCC_OscConfig+0x5ee>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 800bb54:	4bcd      	ldr	r3, [pc, #820]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bb56:	685b      	ldr	r3, [r3, #4]
 800bb58:	f003 030c 	and.w	r3, r3, #12
 800bb5c:	2b00      	cmp	r3, #0
 800bb5e:	d00c      	beq.n	800bb7a <HAL_RCC_OscConfig+0x33a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 800bb60:	4bca      	ldr	r3, [pc, #808]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bb62:	685b      	ldr	r3, [r3, #4]
 800bb64:	f003 030c 	and.w	r3, r3, #12
 800bb68:	2b08      	cmp	r3, #8
 800bb6a:	d16e      	bne.n	800bc4a <HAL_RCC_OscConfig+0x40a>
 800bb6c:	4bc7      	ldr	r3, [pc, #796]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bb6e:	685b      	ldr	r3, [r3, #4]
 800bb70:	f403 33c0 	and.w	r3, r3, #98304	@ 0x18000
 800bb74:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800bb78:	d167      	bne.n	800bc4a <HAL_RCC_OscConfig+0x40a>
 800bb7a:	2302      	movs	r3, #2
 800bb7c:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bb80:	f8d7 3194 	ldr.w	r3, [r7, #404]	@ 0x194
 800bb84:	fa93 f3a3 	rbit	r3, r3
 800bb88:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
  return result;
 800bb8c:	f8d7 3190 	ldr.w	r3, [r7, #400]	@ 0x190
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800bb90:	fab3 f383 	clz	r3, r3
 800bb94:	b2db      	uxtb	r3, r3
 800bb96:	2b3f      	cmp	r3, #63	@ 0x3f
 800bb98:	d802      	bhi.n	800bba0 <HAL_RCC_OscConfig+0x360>
 800bb9a:	4bbc      	ldr	r3, [pc, #752]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bb9c:	681b      	ldr	r3, [r3, #0]
 800bb9e:	e013      	b.n	800bbc8 <HAL_RCC_OscConfig+0x388>
 800bba0:	2302      	movs	r3, #2
 800bba2:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bba6:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 800bbaa:	fa93 f3a3 	rbit	r3, r3
 800bbae:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
 800bbb2:	2302      	movs	r3, #2
 800bbb4:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
 800bbb8:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 800bbbc:	fa93 f3a3 	rbit	r3, r3
 800bbc0:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
 800bbc4:	4bb1      	ldr	r3, [pc, #708]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bbc6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bbc8:	2202      	movs	r2, #2
 800bbca:	f8c7 217c 	str.w	r2, [r7, #380]	@ 0x17c
 800bbce:	f8d7 217c 	ldr.w	r2, [r7, #380]	@ 0x17c
 800bbd2:	fa92 f2a2 	rbit	r2, r2
 800bbd6:	f8c7 2178 	str.w	r2, [r7, #376]	@ 0x178
  return result;
 800bbda:	f8d7 2178 	ldr.w	r2, [r7, #376]	@ 0x178
 800bbde:	fab2 f282 	clz	r2, r2
 800bbe2:	b2d2      	uxtb	r2, r2
 800bbe4:	f042 0220 	orr.w	r2, r2, #32
 800bbe8:	b2d2      	uxtb	r2, r2
 800bbea:	f002 021f 	and.w	r2, r2, #31
 800bbee:	2101      	movs	r1, #1
 800bbf0:	fa01 f202 	lsl.w	r2, r1, r2
 800bbf4:	4013      	ands	r3, r2
 800bbf6:	2b00      	cmp	r3, #0
 800bbf8:	d00a      	beq.n	800bc10 <HAL_RCC_OscConfig+0x3d0>
 800bbfa:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bbfe:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800bc02:	681b      	ldr	r3, [r3, #0]
 800bc04:	68db      	ldr	r3, [r3, #12]
 800bc06:	2b01      	cmp	r3, #1
 800bc08:	d002      	beq.n	800bc10 <HAL_RCC_OscConfig+0x3d0>
      {
        return HAL_ERROR;
 800bc0a:	2301      	movs	r3, #1
 800bc0c:	f000 be35 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800bc10:	4b9e      	ldr	r3, [pc, #632]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bc12:	681b      	ldr	r3, [r3, #0]
 800bc14:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800bc18:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bc1c:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800bc20:	681b      	ldr	r3, [r3, #0]
 800bc22:	691b      	ldr	r3, [r3, #16]
 800bc24:	21f8      	movs	r1, #248	@ 0xf8
 800bc26:	f8c7 1174 	str.w	r1, [r7, #372]	@ 0x174
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bc2a:	f8d7 1174 	ldr.w	r1, [r7, #372]	@ 0x174
 800bc2e:	fa91 f1a1 	rbit	r1, r1
 800bc32:	f8c7 1170 	str.w	r1, [r7, #368]	@ 0x170
  return result;
 800bc36:	f8d7 1170 	ldr.w	r1, [r7, #368]	@ 0x170
 800bc3a:	fab1 f181 	clz	r1, r1
 800bc3e:	b2c9      	uxtb	r1, r1
 800bc40:	408b      	lsls	r3, r1
 800bc42:	4992      	ldr	r1, [pc, #584]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bc44:	4313      	orrs	r3, r2
 800bc46:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800bc48:	e0f1      	b.n	800be2e <HAL_RCC_OscConfig+0x5ee>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800bc4a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bc4e:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800bc52:	681b      	ldr	r3, [r3, #0]
 800bc54:	68db      	ldr	r3, [r3, #12]
 800bc56:	2b00      	cmp	r3, #0
 800bc58:	f000 8083 	beq.w	800bd62 <HAL_RCC_OscConfig+0x522>
 800bc5c:	2301      	movs	r3, #1
 800bc5e:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bc62:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 800bc66:	fa93 f3a3 	rbit	r3, r3
 800bc6a:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
  return result;
 800bc6e:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800bc72:	fab3 f383 	clz	r3, r3
 800bc76:	b2db      	uxtb	r3, r3
 800bc78:	f103 5384 	add.w	r3, r3, #276824064	@ 0x10800000
 800bc7c:	f503 1384 	add.w	r3, r3, #1081344	@ 0x108000
 800bc80:	009b      	lsls	r3, r3, #2
 800bc82:	461a      	mov	r2, r3
 800bc84:	2301      	movs	r3, #1
 800bc86:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800bc88:	f7fe ff4a 	bl	800ab20 <HAL_GetTick>
 800bc8c:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800bc90:	e00a      	b.n	800bca8 <HAL_RCC_OscConfig+0x468>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800bc92:	f7fe ff45 	bl	800ab20 <HAL_GetTick>
 800bc96:	4602      	mov	r2, r0
 800bc98:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800bc9c:	1ad3      	subs	r3, r2, r3
 800bc9e:	2b02      	cmp	r3, #2
 800bca0:	d902      	bls.n	800bca8 <HAL_RCC_OscConfig+0x468>
          {
            return HAL_TIMEOUT;
 800bca2:	2303      	movs	r3, #3
 800bca4:	f000 bde9 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
 800bca8:	2302      	movs	r3, #2
 800bcaa:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bcae:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 800bcb2:	fa93 f3a3 	rbit	r3, r3
 800bcb6:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
  return result;
 800bcba:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800bcbe:	fab3 f383 	clz	r3, r3
 800bcc2:	b2db      	uxtb	r3, r3
 800bcc4:	2b3f      	cmp	r3, #63	@ 0x3f
 800bcc6:	d802      	bhi.n	800bcce <HAL_RCC_OscConfig+0x48e>
 800bcc8:	4b70      	ldr	r3, [pc, #448]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bcca:	681b      	ldr	r3, [r3, #0]
 800bccc:	e013      	b.n	800bcf6 <HAL_RCC_OscConfig+0x4b6>
 800bcce:	2302      	movs	r3, #2
 800bcd0:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bcd4:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 800bcd8:	fa93 f3a3 	rbit	r3, r3
 800bcdc:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
 800bce0:	2302      	movs	r3, #2
 800bce2:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 800bce6:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 800bcea:	fa93 f3a3 	rbit	r3, r3
 800bcee:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
 800bcf2:	4b66      	ldr	r3, [pc, #408]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bcf4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bcf6:	2202      	movs	r2, #2
 800bcf8:	f8c7 214c 	str.w	r2, [r7, #332]	@ 0x14c
 800bcfc:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 800bd00:	fa92 f2a2 	rbit	r2, r2
 800bd04:	f8c7 2148 	str.w	r2, [r7, #328]	@ 0x148
  return result;
 800bd08:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 800bd0c:	fab2 f282 	clz	r2, r2
 800bd10:	b2d2      	uxtb	r2, r2
 800bd12:	f042 0220 	orr.w	r2, r2, #32
 800bd16:	b2d2      	uxtb	r2, r2
 800bd18:	f002 021f 	and.w	r2, r2, #31
 800bd1c:	2101      	movs	r1, #1
 800bd1e:	fa01 f202 	lsl.w	r2, r1, r2
 800bd22:	4013      	ands	r3, r2
 800bd24:	2b00      	cmp	r3, #0
 800bd26:	d0b4      	beq.n	800bc92 <HAL_RCC_OscConfig+0x452>
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800bd28:	4b58      	ldr	r3, [pc, #352]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bd2a:	681b      	ldr	r3, [r3, #0]
 800bd2c:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800bd30:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bd34:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800bd38:	681b      	ldr	r3, [r3, #0]
 800bd3a:	691b      	ldr	r3, [r3, #16]
 800bd3c:	21f8      	movs	r1, #248	@ 0xf8
 800bd3e:	f8c7 1144 	str.w	r1, [r7, #324]	@ 0x144
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bd42:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 800bd46:	fa91 f1a1 	rbit	r1, r1
 800bd4a:	f8c7 1140 	str.w	r1, [r7, #320]	@ 0x140
  return result;
 800bd4e:	f8d7 1140 	ldr.w	r1, [r7, #320]	@ 0x140
 800bd52:	fab1 f181 	clz	r1, r1
 800bd56:	b2c9      	uxtb	r1, r1
 800bd58:	408b      	lsls	r3, r1
 800bd5a:	494c      	ldr	r1, [pc, #304]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bd5c:	4313      	orrs	r3, r2
 800bd5e:	600b      	str	r3, [r1, #0]
 800bd60:	e065      	b.n	800be2e <HAL_RCC_OscConfig+0x5ee>
 800bd62:	2301      	movs	r3, #1
 800bd64:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bd68:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 800bd6c:	fa93 f3a3 	rbit	r3, r3
 800bd70:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
  return result;
 800bd74:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800bd78:	fab3 f383 	clz	r3, r3
 800bd7c:	b2db      	uxtb	r3, r3
 800bd7e:	f103 5384 	add.w	r3, r3, #276824064	@ 0x10800000
 800bd82:	f503 1384 	add.w	r3, r3, #1081344	@ 0x108000
 800bd86:	009b      	lsls	r3, r3, #2
 800bd88:	461a      	mov	r2, r3
 800bd8a:	2300      	movs	r3, #0
 800bd8c:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800bd8e:	f7fe fec7 	bl	800ab20 <HAL_GetTick>
 800bd92:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800bd96:	e00a      	b.n	800bdae <HAL_RCC_OscConfig+0x56e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800bd98:	f7fe fec2 	bl	800ab20 <HAL_GetTick>
 800bd9c:	4602      	mov	r2, r0
 800bd9e:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800bda2:	1ad3      	subs	r3, r2, r3
 800bda4:	2b02      	cmp	r3, #2
 800bda6:	d902      	bls.n	800bdae <HAL_RCC_OscConfig+0x56e>
          {
            return HAL_TIMEOUT;
 800bda8:	2303      	movs	r3, #3
 800bdaa:	f000 bd66 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
 800bdae:	2302      	movs	r3, #2
 800bdb0:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bdb4:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 800bdb8:	fa93 f3a3 	rbit	r3, r3
 800bdbc:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
  return result;
 800bdc0:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800bdc4:	fab3 f383 	clz	r3, r3
 800bdc8:	b2db      	uxtb	r3, r3
 800bdca:	2b3f      	cmp	r3, #63	@ 0x3f
 800bdcc:	d802      	bhi.n	800bdd4 <HAL_RCC_OscConfig+0x594>
 800bdce:	4b2f      	ldr	r3, [pc, #188]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bdd0:	681b      	ldr	r3, [r3, #0]
 800bdd2:	e013      	b.n	800bdfc <HAL_RCC_OscConfig+0x5bc>
 800bdd4:	2302      	movs	r3, #2
 800bdd6:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bdda:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 800bdde:	fa93 f3a3 	rbit	r3, r3
 800bde2:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
 800bde6:	2302      	movs	r3, #2
 800bde8:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 800bdec:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 800bdf0:	fa93 f3a3 	rbit	r3, r3
 800bdf4:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 800bdf8:	4b24      	ldr	r3, [pc, #144]	@ (800be8c <HAL_RCC_OscConfig+0x64c>)
 800bdfa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bdfc:	2202      	movs	r2, #2
 800bdfe:	f8c7 211c 	str.w	r2, [r7, #284]	@ 0x11c
 800be02:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 800be06:	fa92 f2a2 	rbit	r2, r2
 800be0a:	f8c7 2118 	str.w	r2, [r7, #280]	@ 0x118
  return result;
 800be0e:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 800be12:	fab2 f282 	clz	r2, r2
 800be16:	b2d2      	uxtb	r2, r2
 800be18:	f042 0220 	orr.w	r2, r2, #32
 800be1c:	b2d2      	uxtb	r2, r2
 800be1e:	f002 021f 	and.w	r2, r2, #31
 800be22:	2101      	movs	r1, #1
 800be24:	fa01 f202 	lsl.w	r2, r1, r2
 800be28:	4013      	ands	r3, r2
 800be2a:	2b00      	cmp	r3, #0
 800be2c:	d1b4      	bne.n	800bd98 <HAL_RCC_OscConfig+0x558>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800be2e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800be32:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800be36:	681b      	ldr	r3, [r3, #0]
 800be38:	681b      	ldr	r3, [r3, #0]
 800be3a:	f003 0308 	and.w	r3, r3, #8
 800be3e:	2b00      	cmp	r3, #0
 800be40:	f000 8119 	beq.w	800c076 <HAL_RCC_OscConfig+0x836>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800be44:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800be48:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800be4c:	681b      	ldr	r3, [r3, #0]
 800be4e:	695b      	ldr	r3, [r3, #20]
 800be50:	2b00      	cmp	r3, #0
 800be52:	f000 8082 	beq.w	800bf5a <HAL_RCC_OscConfig+0x71a>
 800be56:	2301      	movs	r3, #1
 800be58:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800be5c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800be60:	fa93 f3a3 	rbit	r3, r3
 800be64:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
  return result;
 800be68:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800be6c:	fab3 f383 	clz	r3, r3
 800be70:	b2db      	uxtb	r3, r3
 800be72:	461a      	mov	r2, r3
 800be74:	4b06      	ldr	r3, [pc, #24]	@ (800be90 <HAL_RCC_OscConfig+0x650>)
 800be76:	4413      	add	r3, r2
 800be78:	009b      	lsls	r3, r3, #2
 800be7a:	461a      	mov	r2, r3
 800be7c:	2301      	movs	r3, #1
 800be7e:	6013      	str	r3, [r2, #0]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800be80:	f7fe fe4e 	bl	800ab20 <HAL_GetTick>
 800be84:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800be88:	e00f      	b.n	800beaa <HAL_RCC_OscConfig+0x66a>
 800be8a:	bf00      	nop
 800be8c:	40021000 	.word	0x40021000
 800be90:	10908120 	.word	0x10908120
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800be94:	f7fe fe44 	bl	800ab20 <HAL_GetTick>
 800be98:	4602      	mov	r2, r0
 800be9a:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800be9e:	1ad3      	subs	r3, r2, r3
 800bea0:	2b02      	cmp	r3, #2
 800bea2:	d902      	bls.n	800beaa <HAL_RCC_OscConfig+0x66a>
        {
          return HAL_TIMEOUT;
 800bea4:	2303      	movs	r3, #3
 800bea6:	f000 bce8 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
 800beaa:	2302      	movs	r3, #2
 800beac:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800beb0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800beb4:	fa93 f2a3 	rbit	r2, r3
 800beb8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bebc:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800bec0:	601a      	str	r2, [r3, #0]
 800bec2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bec6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800beca:	2202      	movs	r2, #2
 800becc:	601a      	str	r2, [r3, #0]
 800bece:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bed2:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800bed6:	681b      	ldr	r3, [r3, #0]
 800bed8:	fa93 f2a3 	rbit	r2, r3
 800bedc:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bee0:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
 800bee4:	601a      	str	r2, [r3, #0]
 800bee6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800beea:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 800beee:	2202      	movs	r2, #2
 800bef0:	601a      	str	r2, [r3, #0]
 800bef2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bef6:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 800befa:	681b      	ldr	r3, [r3, #0]
 800befc:	fa93 f2a3 	rbit	r2, r3
 800bf00:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf04:	f5a3 7388 	sub.w	r3, r3, #272	@ 0x110
 800bf08:	601a      	str	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800bf0a:	4bb0      	ldr	r3, [pc, #704]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800bf0c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800bf0e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf12:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 800bf16:	2102      	movs	r1, #2
 800bf18:	6019      	str	r1, [r3, #0]
 800bf1a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf1e:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 800bf22:	681b      	ldr	r3, [r3, #0]
 800bf24:	fa93 f1a3 	rbit	r1, r3
 800bf28:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf2c:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 800bf30:	6019      	str	r1, [r3, #0]
  return result;
 800bf32:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf36:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 800bf3a:	681b      	ldr	r3, [r3, #0]
 800bf3c:	fab3 f383 	clz	r3, r3
 800bf40:	b2db      	uxtb	r3, r3
 800bf42:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 800bf46:	b2db      	uxtb	r3, r3
 800bf48:	f003 031f 	and.w	r3, r3, #31
 800bf4c:	2101      	movs	r1, #1
 800bf4e:	fa01 f303 	lsl.w	r3, r1, r3
 800bf52:	4013      	ands	r3, r2
 800bf54:	2b00      	cmp	r3, #0
 800bf56:	d09d      	beq.n	800be94 <HAL_RCC_OscConfig+0x654>
 800bf58:	e08d      	b.n	800c076 <HAL_RCC_OscConfig+0x836>
 800bf5a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf5e:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 800bf62:	2201      	movs	r2, #1
 800bf64:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bf66:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf6a:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 800bf6e:	681b      	ldr	r3, [r3, #0]
 800bf70:	fa93 f2a3 	rbit	r2, r3
 800bf74:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf78:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 800bf7c:	601a      	str	r2, [r3, #0]
  return result;
 800bf7e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bf82:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 800bf86:	681b      	ldr	r3, [r3, #0]
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800bf88:	fab3 f383 	clz	r3, r3
 800bf8c:	b2db      	uxtb	r3, r3
 800bf8e:	461a      	mov	r2, r3
 800bf90:	4b8f      	ldr	r3, [pc, #572]	@ (800c1d0 <HAL_RCC_OscConfig+0x990>)
 800bf92:	4413      	add	r3, r2
 800bf94:	009b      	lsls	r3, r3, #2
 800bf96:	461a      	mov	r2, r3
 800bf98:	2300      	movs	r3, #0
 800bf9a:	6013      	str	r3, [r2, #0]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800bf9c:	f7fe fdc0 	bl	800ab20 <HAL_GetTick>
 800bfa0:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800bfa4:	e00a      	b.n	800bfbc <HAL_RCC_OscConfig+0x77c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800bfa6:	f7fe fdbb 	bl	800ab20 <HAL_GetTick>
 800bfaa:	4602      	mov	r2, r0
 800bfac:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800bfb0:	1ad3      	subs	r3, r2, r3
 800bfb2:	2b02      	cmp	r3, #2
 800bfb4:	d902      	bls.n	800bfbc <HAL_RCC_OscConfig+0x77c>
        {
          return HAL_TIMEOUT;
 800bfb6:	2303      	movs	r3, #3
 800bfb8:	f000 bc5f 	b.w	800c87a <HAL_RCC_OscConfig+0x103a>
 800bfbc:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bfc0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 800bfc4:	2202      	movs	r2, #2
 800bfc6:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800bfc8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bfcc:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 800bfd0:	681b      	ldr	r3, [r3, #0]
 800bfd2:	fa93 f2a3 	rbit	r2, r3
 800bfd6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bfda:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 800bfde:	601a      	str	r2, [r3, #0]
 800bfe0:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bfe4:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800bfe8:	2202      	movs	r2, #2
 800bfea:	601a      	str	r2, [r3, #0]
 800bfec:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bff0:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 800bff4:	681b      	ldr	r3, [r3, #0]
 800bff6:	fa93 f2a3 	rbit	r2, r3
 800bffa:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800bffe:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
 800c002:	601a      	str	r2, [r3, #0]
 800c004:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c008:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 800c00c:	2202      	movs	r2, #2
 800c00e:	601a      	str	r2, [r3, #0]
 800c010:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c014:	f5a3 739a 	sub.w	r3, r3, #308	@ 0x134
 800c018:	681b      	ldr	r3, [r3, #0]
 800c01a:	fa93 f2a3 	rbit	r2, r3
 800c01e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c022:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
 800c026:	601a      	str	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800c028:	4b68      	ldr	r3, [pc, #416]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c02a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800c02c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c030:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
 800c034:	2102      	movs	r1, #2
 800c036:	6019      	str	r1, [r3, #0]
 800c038:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c03c:	f5a3 739e 	sub.w	r3, r3, #316	@ 0x13c
 800c040:	681b      	ldr	r3, [r3, #0]
 800c042:	fa93 f1a3 	rbit	r1, r3
 800c046:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c04a:	f5a3 73a0 	sub.w	r3, r3, #320	@ 0x140
 800c04e:	6019      	str	r1, [r3, #0]
  return result;
 800c050:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c054:	f5a3 73a0 	sub.w	r3, r3, #320	@ 0x140
 800c058:	681b      	ldr	r3, [r3, #0]
 800c05a:	fab3 f383 	clz	r3, r3
 800c05e:	b2db      	uxtb	r3, r3
 800c060:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 800c064:	b2db      	uxtb	r3, r3
 800c066:	f003 031f 	and.w	r3, r3, #31
 800c06a:	2101      	movs	r1, #1
 800c06c:	fa01 f303 	lsl.w	r3, r1, r3
 800c070:	4013      	ands	r3, r2
 800c072:	2b00      	cmp	r3, #0
 800c074:	d197      	bne.n	800bfa6 <HAL_RCC_OscConfig+0x766>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800c076:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c07a:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c07e:	681b      	ldr	r3, [r3, #0]
 800c080:	681b      	ldr	r3, [r3, #0]
 800c082:	f003 0304 	and.w	r3, r3, #4
 800c086:	2b00      	cmp	r3, #0
 800c088:	f000 819c 	beq.w	800c3c4 <HAL_RCC_OscConfig+0xb84>
  {
    FlagStatus       pwrclkchanged = RESET;
 800c08c:	2300      	movs	r3, #0
 800c08e:	f887 3207 	strb.w	r3, [r7, #519]	@ 0x207
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800c092:	4b4e      	ldr	r3, [pc, #312]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c094:	69db      	ldr	r3, [r3, #28]
 800c096:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800c09a:	2b00      	cmp	r3, #0
 800c09c:	d116      	bne.n	800c0cc <HAL_RCC_OscConfig+0x88c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800c09e:	4b4b      	ldr	r3, [pc, #300]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c0a0:	69db      	ldr	r3, [r3, #28]
 800c0a2:	4a4a      	ldr	r2, [pc, #296]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c0a4:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800c0a8:	61d3      	str	r3, [r2, #28]
 800c0aa:	4b48      	ldr	r3, [pc, #288]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c0ac:	69db      	ldr	r3, [r3, #28]
 800c0ae:	f003 5280 	and.w	r2, r3, #268435456	@ 0x10000000
 800c0b2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c0b6:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
 800c0ba:	601a      	str	r2, [r3, #0]
 800c0bc:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c0c0:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
 800c0c4:	681b      	ldr	r3, [r3, #0]
      pwrclkchanged = SET;
 800c0c6:	2301      	movs	r3, #1
 800c0c8:	f887 3207 	strb.w	r3, [r7, #519]	@ 0x207
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c0cc:	4b41      	ldr	r3, [pc, #260]	@ (800c1d4 <HAL_RCC_OscConfig+0x994>)
 800c0ce:	681b      	ldr	r3, [r3, #0]
 800c0d0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c0d4:	2b00      	cmp	r3, #0
 800c0d6:	d11a      	bne.n	800c10e <HAL_RCC_OscConfig+0x8ce>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800c0d8:	4b3e      	ldr	r3, [pc, #248]	@ (800c1d4 <HAL_RCC_OscConfig+0x994>)
 800c0da:	681b      	ldr	r3, [r3, #0]
 800c0dc:	4a3d      	ldr	r2, [pc, #244]	@ (800c1d4 <HAL_RCC_OscConfig+0x994>)
 800c0de:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800c0e2:	6013      	str	r3, [r2, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800c0e4:	f7fe fd1c 	bl	800ab20 <HAL_GetTick>
 800c0e8:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c0ec:	e009      	b.n	800c102 <HAL_RCC_OscConfig+0x8c2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c0ee:	f7fe fd17 	bl	800ab20 <HAL_GetTick>
 800c0f2:	4602      	mov	r2, r0
 800c0f4:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800c0f8:	1ad3      	subs	r3, r2, r3
 800c0fa:	2b64      	cmp	r3, #100	@ 0x64
 800c0fc:	d901      	bls.n	800c102 <HAL_RCC_OscConfig+0x8c2>
        {
          return HAL_TIMEOUT;
 800c0fe:	2303      	movs	r3, #3
 800c100:	e3bb      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c102:	4b34      	ldr	r3, [pc, #208]	@ (800c1d4 <HAL_RCC_OscConfig+0x994>)
 800c104:	681b      	ldr	r3, [r3, #0]
 800c106:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c10a:	2b00      	cmp	r3, #0
 800c10c:	d0ef      	beq.n	800c0ee <HAL_RCC_OscConfig+0x8ae>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800c10e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c112:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c116:	681b      	ldr	r3, [r3, #0]
 800c118:	689b      	ldr	r3, [r3, #8]
 800c11a:	2b01      	cmp	r3, #1
 800c11c:	d106      	bne.n	800c12c <HAL_RCC_OscConfig+0x8ec>
 800c11e:	4b2b      	ldr	r3, [pc, #172]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c120:	6a1b      	ldr	r3, [r3, #32]
 800c122:	4a2a      	ldr	r2, [pc, #168]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c124:	f043 0301 	orr.w	r3, r3, #1
 800c128:	6213      	str	r3, [r2, #32]
 800c12a:	e035      	b.n	800c198 <HAL_RCC_OscConfig+0x958>
 800c12c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c130:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c134:	681b      	ldr	r3, [r3, #0]
 800c136:	689b      	ldr	r3, [r3, #8]
 800c138:	2b00      	cmp	r3, #0
 800c13a:	d10c      	bne.n	800c156 <HAL_RCC_OscConfig+0x916>
 800c13c:	4b23      	ldr	r3, [pc, #140]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c13e:	6a1b      	ldr	r3, [r3, #32]
 800c140:	4a22      	ldr	r2, [pc, #136]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c142:	f023 0301 	bic.w	r3, r3, #1
 800c146:	6213      	str	r3, [r2, #32]
 800c148:	4b20      	ldr	r3, [pc, #128]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c14a:	6a1b      	ldr	r3, [r3, #32]
 800c14c:	4a1f      	ldr	r2, [pc, #124]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c14e:	f023 0304 	bic.w	r3, r3, #4
 800c152:	6213      	str	r3, [r2, #32]
 800c154:	e020      	b.n	800c198 <HAL_RCC_OscConfig+0x958>
 800c156:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c15a:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c15e:	681b      	ldr	r3, [r3, #0]
 800c160:	689b      	ldr	r3, [r3, #8]
 800c162:	2b05      	cmp	r3, #5
 800c164:	d10c      	bne.n	800c180 <HAL_RCC_OscConfig+0x940>
 800c166:	4b19      	ldr	r3, [pc, #100]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c168:	6a1b      	ldr	r3, [r3, #32]
 800c16a:	4a18      	ldr	r2, [pc, #96]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c16c:	f043 0304 	orr.w	r3, r3, #4
 800c170:	6213      	str	r3, [r2, #32]
 800c172:	4b16      	ldr	r3, [pc, #88]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c174:	6a1b      	ldr	r3, [r3, #32]
 800c176:	4a15      	ldr	r2, [pc, #84]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c178:	f043 0301 	orr.w	r3, r3, #1
 800c17c:	6213      	str	r3, [r2, #32]
 800c17e:	e00b      	b.n	800c198 <HAL_RCC_OscConfig+0x958>
 800c180:	4b12      	ldr	r3, [pc, #72]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c182:	6a1b      	ldr	r3, [r3, #32]
 800c184:	4a11      	ldr	r2, [pc, #68]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c186:	f023 0301 	bic.w	r3, r3, #1
 800c18a:	6213      	str	r3, [r2, #32]
 800c18c:	4b0f      	ldr	r3, [pc, #60]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c18e:	6a1b      	ldr	r3, [r3, #32]
 800c190:	4a0e      	ldr	r2, [pc, #56]	@ (800c1cc <HAL_RCC_OscConfig+0x98c>)
 800c192:	f023 0304 	bic.w	r3, r3, #4
 800c196:	6213      	str	r3, [r2, #32]
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800c198:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c19c:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c1a0:	681b      	ldr	r3, [r3, #0]
 800c1a2:	689b      	ldr	r3, [r3, #8]
 800c1a4:	2b00      	cmp	r3, #0
 800c1a6:	f000 8085 	beq.w	800c2b4 <HAL_RCC_OscConfig+0xa74>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800c1aa:	f7fe fcb9 	bl	800ab20 <HAL_GetTick>
 800c1ae:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800c1b2:	e011      	b.n	800c1d8 <HAL_RCC_OscConfig+0x998>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800c1b4:	f7fe fcb4 	bl	800ab20 <HAL_GetTick>
 800c1b8:	4602      	mov	r2, r0
 800c1ba:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800c1be:	1ad3      	subs	r3, r2, r3
 800c1c0:	f241 3288 	movw	r2, #5000	@ 0x1388
 800c1c4:	4293      	cmp	r3, r2
 800c1c6:	d907      	bls.n	800c1d8 <HAL_RCC_OscConfig+0x998>
        {
          return HAL_TIMEOUT;
 800c1c8:	2303      	movs	r3, #3
 800c1ca:	e356      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
 800c1cc:	40021000 	.word	0x40021000
 800c1d0:	10908120 	.word	0x10908120
 800c1d4:	40007000 	.word	0x40007000
 800c1d8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c1dc:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 800c1e0:	2202      	movs	r2, #2
 800c1e2:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c1e4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c1e8:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 800c1ec:	681b      	ldr	r3, [r3, #0]
 800c1ee:	fa93 f2a3 	rbit	r2, r3
 800c1f2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c1f6:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
 800c1fa:	601a      	str	r2, [r3, #0]
 800c1fc:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c200:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 800c204:	2202      	movs	r2, #2
 800c206:	601a      	str	r2, [r3, #0]
 800c208:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c20c:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 800c210:	681b      	ldr	r3, [r3, #0]
 800c212:	fa93 f2a3 	rbit	r2, r3
 800c216:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c21a:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 800c21e:	601a      	str	r2, [r3, #0]
  return result;
 800c220:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c224:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 800c228:	681b      	ldr	r3, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800c22a:	fab3 f383 	clz	r3, r3
 800c22e:	b2db      	uxtb	r3, r3
 800c230:	f023 035f 	bic.w	r3, r3, #95	@ 0x5f
 800c234:	b2db      	uxtb	r3, r3
 800c236:	2b00      	cmp	r3, #0
 800c238:	d102      	bne.n	800c240 <HAL_RCC_OscConfig+0xa00>
 800c23a:	4b98      	ldr	r3, [pc, #608]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c23c:	6a1b      	ldr	r3, [r3, #32]
 800c23e:	e013      	b.n	800c268 <HAL_RCC_OscConfig+0xa28>
 800c240:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c244:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 800c248:	2202      	movs	r2, #2
 800c24a:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c24c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c250:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 800c254:	681b      	ldr	r3, [r3, #0]
 800c256:	fa93 f2a3 	rbit	r2, r3
 800c25a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c25e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 800c262:	601a      	str	r2, [r3, #0]
 800c264:	4b8d      	ldr	r3, [pc, #564]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c266:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c268:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c26c:	f5a2 72ae 	sub.w	r2, r2, #348	@ 0x15c
 800c270:	2102      	movs	r1, #2
 800c272:	6011      	str	r1, [r2, #0]
 800c274:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c278:	f5a2 72ae 	sub.w	r2, r2, #348	@ 0x15c
 800c27c:	6812      	ldr	r2, [r2, #0]
 800c27e:	fa92 f1a2 	rbit	r1, r2
 800c282:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c286:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
 800c28a:	6011      	str	r1, [r2, #0]
  return result;
 800c28c:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c290:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
 800c294:	6812      	ldr	r2, [r2, #0]
 800c296:	fab2 f282 	clz	r2, r2
 800c29a:	b2d2      	uxtb	r2, r2
 800c29c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800c2a0:	b2d2      	uxtb	r2, r2
 800c2a2:	f002 021f 	and.w	r2, r2, #31
 800c2a6:	2101      	movs	r1, #1
 800c2a8:	fa01 f202 	lsl.w	r2, r1, r2
 800c2ac:	4013      	ands	r3, r2
 800c2ae:	2b00      	cmp	r3, #0
 800c2b0:	d080      	beq.n	800c1b4 <HAL_RCC_OscConfig+0x974>
 800c2b2:	e07d      	b.n	800c3b0 <HAL_RCC_OscConfig+0xb70>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800c2b4:	f7fe fc34 	bl	800ab20 <HAL_GetTick>
 800c2b8:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800c2bc:	e00b      	b.n	800c2d6 <HAL_RCC_OscConfig+0xa96>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800c2be:	f7fe fc2f 	bl	800ab20 <HAL_GetTick>
 800c2c2:	4602      	mov	r2, r0
 800c2c4:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800c2c8:	1ad3      	subs	r3, r2, r3
 800c2ca:	f241 3288 	movw	r2, #5000	@ 0x1388
 800c2ce:	4293      	cmp	r3, r2
 800c2d0:	d901      	bls.n	800c2d6 <HAL_RCC_OscConfig+0xa96>
        {
          return HAL_TIMEOUT;
 800c2d2:	2303      	movs	r3, #3
 800c2d4:	e2d1      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
 800c2d6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c2da:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 800c2de:	2202      	movs	r2, #2
 800c2e0:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c2e2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c2e6:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 800c2ea:	681b      	ldr	r3, [r3, #0]
 800c2ec:	fa93 f2a3 	rbit	r2, r3
 800c2f0:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c2f4:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
 800c2f8:	601a      	str	r2, [r3, #0]
 800c2fa:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c2fe:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
 800c302:	2202      	movs	r2, #2
 800c304:	601a      	str	r2, [r3, #0]
 800c306:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c30a:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
 800c30e:	681b      	ldr	r3, [r3, #0]
 800c310:	fa93 f2a3 	rbit	r2, r3
 800c314:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c318:	f5a3 73b8 	sub.w	r3, r3, #368	@ 0x170
 800c31c:	601a      	str	r2, [r3, #0]
  return result;
 800c31e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c322:	f5a3 73b8 	sub.w	r3, r3, #368	@ 0x170
 800c326:	681b      	ldr	r3, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800c328:	fab3 f383 	clz	r3, r3
 800c32c:	b2db      	uxtb	r3, r3
 800c32e:	f023 035f 	bic.w	r3, r3, #95	@ 0x5f
 800c332:	b2db      	uxtb	r3, r3
 800c334:	2b00      	cmp	r3, #0
 800c336:	d102      	bne.n	800c33e <HAL_RCC_OscConfig+0xafe>
 800c338:	4b58      	ldr	r3, [pc, #352]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c33a:	6a1b      	ldr	r3, [r3, #32]
 800c33c:	e013      	b.n	800c366 <HAL_RCC_OscConfig+0xb26>
 800c33e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c342:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 800c346:	2202      	movs	r2, #2
 800c348:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c34a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c34e:	f5a3 73ba 	sub.w	r3, r3, #372	@ 0x174
 800c352:	681b      	ldr	r3, [r3, #0]
 800c354:	fa93 f2a3 	rbit	r2, r3
 800c358:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c35c:	f5a3 73bc 	sub.w	r3, r3, #376	@ 0x178
 800c360:	601a      	str	r2, [r3, #0]
 800c362:	4b4e      	ldr	r3, [pc, #312]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c364:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c366:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c36a:	f5a2 72be 	sub.w	r2, r2, #380	@ 0x17c
 800c36e:	2102      	movs	r1, #2
 800c370:	6011      	str	r1, [r2, #0]
 800c372:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c376:	f5a2 72be 	sub.w	r2, r2, #380	@ 0x17c
 800c37a:	6812      	ldr	r2, [r2, #0]
 800c37c:	fa92 f1a2 	rbit	r1, r2
 800c380:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c384:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 800c388:	6011      	str	r1, [r2, #0]
  return result;
 800c38a:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c38e:	f5a2 72c0 	sub.w	r2, r2, #384	@ 0x180
 800c392:	6812      	ldr	r2, [r2, #0]
 800c394:	fab2 f282 	clz	r2, r2
 800c398:	b2d2      	uxtb	r2, r2
 800c39a:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800c39e:	b2d2      	uxtb	r2, r2
 800c3a0:	f002 021f 	and.w	r2, r2, #31
 800c3a4:	2101      	movs	r1, #1
 800c3a6:	fa01 f202 	lsl.w	r2, r1, r2
 800c3aa:	4013      	ands	r3, r2
 800c3ac:	2b00      	cmp	r3, #0
 800c3ae:	d186      	bne.n	800c2be <HAL_RCC_OscConfig+0xa7e>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800c3b0:	f897 3207 	ldrb.w	r3, [r7, #519]	@ 0x207
 800c3b4:	2b01      	cmp	r3, #1
 800c3b6:	d105      	bne.n	800c3c4 <HAL_RCC_OscConfig+0xb84>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800c3b8:	4b38      	ldr	r3, [pc, #224]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c3ba:	69db      	ldr	r3, [r3, #28]
 800c3bc:	4a37      	ldr	r2, [pc, #220]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c3be:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800c3c2:	61d3      	str	r3, [r2, #28]
  }

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800c3c4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c3c8:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c3cc:	681b      	ldr	r3, [r3, #0]
 800c3ce:	699b      	ldr	r3, [r3, #24]
 800c3d0:	2b00      	cmp	r3, #0
 800c3d2:	f000 8251 	beq.w	800c878 <HAL_RCC_OscConfig+0x1038>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800c3d6:	4b31      	ldr	r3, [pc, #196]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c3d8:	685b      	ldr	r3, [r3, #4]
 800c3da:	f003 030c 	and.w	r3, r3, #12
 800c3de:	2b08      	cmp	r3, #8
 800c3e0:	f000 820f 	beq.w	800c802 <HAL_RCC_OscConfig+0xfc2>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800c3e4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c3e8:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c3ec:	681b      	ldr	r3, [r3, #0]
 800c3ee:	699b      	ldr	r3, [r3, #24]
 800c3f0:	2b02      	cmp	r3, #2
 800c3f2:	f040 8165 	bne.w	800c6c0 <HAL_RCC_OscConfig+0xe80>
 800c3f6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c3fa:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 800c3fe:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800c402:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c404:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c408:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 800c40c:	681b      	ldr	r3, [r3, #0]
 800c40e:	fa93 f2a3 	rbit	r2, r3
 800c412:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c416:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 800c41a:	601a      	str	r2, [r3, #0]
  return result;
 800c41c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c420:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 800c424:	681b      	ldr	r3, [r3, #0]
#if   defined(RCC_CFGR_PLLSRC_HSI_PREDIV)
        assert_param(IS_RCC_PREDIV(RCC_OscInitStruct->PLL.PREDIV));
#endif
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800c426:	fab3 f383 	clz	r3, r3
 800c42a:	b2db      	uxtb	r3, r3
 800c42c:	f103 5384 	add.w	r3, r3, #276824064	@ 0x10800000
 800c430:	f503 1384 	add.w	r3, r3, #1081344	@ 0x108000
 800c434:	009b      	lsls	r3, r3, #2
 800c436:	461a      	mov	r2, r3
 800c438:	2300      	movs	r3, #0
 800c43a:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800c43c:	f7fe fb70 	bl	800ab20 <HAL_GetTick>
 800c440:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800c444:	e009      	b.n	800c45a <HAL_RCC_OscConfig+0xc1a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800c446:	f7fe fb6b 	bl	800ab20 <HAL_GetTick>
 800c44a:	4602      	mov	r2, r0
 800c44c:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800c450:	1ad3      	subs	r3, r2, r3
 800c452:	2b02      	cmp	r3, #2
 800c454:	d901      	bls.n	800c45a <HAL_RCC_OscConfig+0xc1a>
          {
            return HAL_TIMEOUT;
 800c456:	2303      	movs	r3, #3
 800c458:	e20f      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
 800c45a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c45e:	f5a3 73c6 	sub.w	r3, r3, #396	@ 0x18c
 800c462:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c466:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c468:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c46c:	f5a3 73c6 	sub.w	r3, r3, #396	@ 0x18c
 800c470:	681b      	ldr	r3, [r3, #0]
 800c472:	fa93 f2a3 	rbit	r2, r3
 800c476:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c47a:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 800c47e:	601a      	str	r2, [r3, #0]
  return result;
 800c480:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c484:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 800c488:	681b      	ldr	r3, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800c48a:	fab3 f383 	clz	r3, r3
 800c48e:	b2db      	uxtb	r3, r3
 800c490:	2b3f      	cmp	r3, #63	@ 0x3f
 800c492:	d805      	bhi.n	800c4a0 <HAL_RCC_OscConfig+0xc60>
 800c494:	4b01      	ldr	r3, [pc, #4]	@ (800c49c <HAL_RCC_OscConfig+0xc5c>)
 800c496:	681b      	ldr	r3, [r3, #0]
 800c498:	e02a      	b.n	800c4f0 <HAL_RCC_OscConfig+0xcb0>
 800c49a:	bf00      	nop
 800c49c:	40021000 	.word	0x40021000
 800c4a0:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c4a4:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
 800c4a8:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c4ac:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c4ae:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c4b2:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
 800c4b6:	681b      	ldr	r3, [r3, #0]
 800c4b8:	fa93 f2a3 	rbit	r2, r3
 800c4bc:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c4c0:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
 800c4c4:	601a      	str	r2, [r3, #0]
 800c4c6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c4ca:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
 800c4ce:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c4d2:	601a      	str	r2, [r3, #0]
 800c4d4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c4d8:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
 800c4dc:	681b      	ldr	r3, [r3, #0]
 800c4de:	fa93 f2a3 	rbit	r2, r3
 800c4e2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c4e6:	f5a3 73d0 	sub.w	r3, r3, #416	@ 0x1a0
 800c4ea:	601a      	str	r2, [r3, #0]
 800c4ec:	4bca      	ldr	r3, [pc, #808]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c4ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c4f0:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c4f4:	f5a2 72d2 	sub.w	r2, r2, #420	@ 0x1a4
 800c4f8:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
 800c4fc:	6011      	str	r1, [r2, #0]
 800c4fe:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c502:	f5a2 72d2 	sub.w	r2, r2, #420	@ 0x1a4
 800c506:	6812      	ldr	r2, [r2, #0]
 800c508:	fa92 f1a2 	rbit	r1, r2
 800c50c:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c510:	f5a2 72d4 	sub.w	r2, r2, #424	@ 0x1a8
 800c514:	6011      	str	r1, [r2, #0]
  return result;
 800c516:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c51a:	f5a2 72d4 	sub.w	r2, r2, #424	@ 0x1a8
 800c51e:	6812      	ldr	r2, [r2, #0]
 800c520:	fab2 f282 	clz	r2, r2
 800c524:	b2d2      	uxtb	r2, r2
 800c526:	f042 0220 	orr.w	r2, r2, #32
 800c52a:	b2d2      	uxtb	r2, r2
 800c52c:	f002 021f 	and.w	r2, r2, #31
 800c530:	2101      	movs	r1, #1
 800c532:	fa01 f202 	lsl.w	r2, r1, r2
 800c536:	4013      	ands	r3, r2
 800c538:	2b00      	cmp	r3, #0
 800c53a:	d184      	bne.n	800c446 <HAL_RCC_OscConfig+0xc06>
          }
        }

#if defined(RCC_CFGR_PLLSRC_HSI_PREDIV)
        /* Configure the main PLL clock source, predivider and multiplication factor. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800c53c:	4bb6      	ldr	r3, [pc, #728]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c53e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c540:	f023 020f 	bic.w	r2, r3, #15
 800c544:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c548:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c54c:	681b      	ldr	r3, [r3, #0]
 800c54e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c550:	49b1      	ldr	r1, [pc, #708]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c552:	4313      	orrs	r3, r2
 800c554:	62cb      	str	r3, [r1, #44]	@ 0x2c
 800c556:	4bb0      	ldr	r3, [pc, #704]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c558:	685b      	ldr	r3, [r3, #4]
 800c55a:	f423 1276 	bic.w	r2, r3, #4030464	@ 0x3d8000
 800c55e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c562:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c566:	681b      	ldr	r3, [r3, #0]
 800c568:	6a19      	ldr	r1, [r3, #32]
 800c56a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c56e:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c572:	681b      	ldr	r3, [r3, #0]
 800c574:	69db      	ldr	r3, [r3, #28]
 800c576:	430b      	orrs	r3, r1
 800c578:	49a7      	ldr	r1, [pc, #668]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c57a:	4313      	orrs	r3, r2
 800c57c:	604b      	str	r3, [r1, #4]
 800c57e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c582:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
 800c586:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800c58a:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c58c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c590:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
 800c594:	681b      	ldr	r3, [r3, #0]
 800c596:	fa93 f2a3 	rbit	r2, r3
 800c59a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c59e:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 800c5a2:	601a      	str	r2, [r3, #0]
  return result;
 800c5a4:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c5a8:	f5a3 73d8 	sub.w	r3, r3, #432	@ 0x1b0
 800c5ac:	681b      	ldr	r3, [r3, #0]
      /* Configure the main PLL clock source and multiplication factor. */
      __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
                           RCC_OscInitStruct->PLL.PLLMUL);
#endif /* RCC_CFGR_PLLSRC_HSI_PREDIV */
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800c5ae:	fab3 f383 	clz	r3, r3
 800c5b2:	b2db      	uxtb	r3, r3
 800c5b4:	f103 5384 	add.w	r3, r3, #276824064	@ 0x10800000
 800c5b8:	f503 1384 	add.w	r3, r3, #1081344	@ 0x108000
 800c5bc:	009b      	lsls	r3, r3, #2
 800c5be:	461a      	mov	r2, r3
 800c5c0:	2301      	movs	r3, #1
 800c5c2:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800c5c4:	f7fe faac 	bl	800ab20 <HAL_GetTick>
 800c5c8:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800c5cc:	e009      	b.n	800c5e2 <HAL_RCC_OscConfig+0xda2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800c5ce:	f7fe faa7 	bl	800ab20 <HAL_GetTick>
 800c5d2:	4602      	mov	r2, r0
 800c5d4:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800c5d8:	1ad3      	subs	r3, r2, r3
 800c5da:	2b02      	cmp	r3, #2
 800c5dc:	d901      	bls.n	800c5e2 <HAL_RCC_OscConfig+0xda2>
          {
            return HAL_TIMEOUT;
 800c5de:	2303      	movs	r3, #3
 800c5e0:	e14b      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
 800c5e2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c5e6:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 800c5ea:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c5ee:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c5f0:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c5f4:	f5a3 73da 	sub.w	r3, r3, #436	@ 0x1b4
 800c5f8:	681b      	ldr	r3, [r3, #0]
 800c5fa:	fa93 f2a3 	rbit	r2, r3
 800c5fe:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c602:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 800c606:	601a      	str	r2, [r3, #0]
  return result;
 800c608:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c60c:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 800c610:	681b      	ldr	r3, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800c612:	fab3 f383 	clz	r3, r3
 800c616:	b2db      	uxtb	r3, r3
 800c618:	2b3f      	cmp	r3, #63	@ 0x3f
 800c61a:	d802      	bhi.n	800c622 <HAL_RCC_OscConfig+0xde2>
 800c61c:	4b7e      	ldr	r3, [pc, #504]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c61e:	681b      	ldr	r3, [r3, #0]
 800c620:	e027      	b.n	800c672 <HAL_RCC_OscConfig+0xe32>
 800c622:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c626:	f5a3 73de 	sub.w	r3, r3, #444	@ 0x1bc
 800c62a:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c62e:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c630:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c634:	f5a3 73de 	sub.w	r3, r3, #444	@ 0x1bc
 800c638:	681b      	ldr	r3, [r3, #0]
 800c63a:	fa93 f2a3 	rbit	r2, r3
 800c63e:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c642:	f5a3 73e0 	sub.w	r3, r3, #448	@ 0x1c0
 800c646:	601a      	str	r2, [r3, #0]
 800c648:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c64c:	f5a3 73e2 	sub.w	r3, r3, #452	@ 0x1c4
 800c650:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c654:	601a      	str	r2, [r3, #0]
 800c656:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c65a:	f5a3 73e2 	sub.w	r3, r3, #452	@ 0x1c4
 800c65e:	681b      	ldr	r3, [r3, #0]
 800c660:	fa93 f2a3 	rbit	r2, r3
 800c664:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c668:	f5a3 73e4 	sub.w	r3, r3, #456	@ 0x1c8
 800c66c:	601a      	str	r2, [r3, #0]
 800c66e:	4b6a      	ldr	r3, [pc, #424]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c670:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c672:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c676:	f5a2 72e6 	sub.w	r2, r2, #460	@ 0x1cc
 800c67a:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
 800c67e:	6011      	str	r1, [r2, #0]
 800c680:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c684:	f5a2 72e6 	sub.w	r2, r2, #460	@ 0x1cc
 800c688:	6812      	ldr	r2, [r2, #0]
 800c68a:	fa92 f1a2 	rbit	r1, r2
 800c68e:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c692:	f5a2 72e8 	sub.w	r2, r2, #464	@ 0x1d0
 800c696:	6011      	str	r1, [r2, #0]
  return result;
 800c698:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c69c:	f5a2 72e8 	sub.w	r2, r2, #464	@ 0x1d0
 800c6a0:	6812      	ldr	r2, [r2, #0]
 800c6a2:	fab2 f282 	clz	r2, r2
 800c6a6:	b2d2      	uxtb	r2, r2
 800c6a8:	f042 0220 	orr.w	r2, r2, #32
 800c6ac:	b2d2      	uxtb	r2, r2
 800c6ae:	f002 021f 	and.w	r2, r2, #31
 800c6b2:	2101      	movs	r1, #1
 800c6b4:	fa01 f202 	lsl.w	r2, r1, r2
 800c6b8:	4013      	ands	r3, r2
 800c6ba:	2b00      	cmp	r3, #0
 800c6bc:	d087      	beq.n	800c5ce <HAL_RCC_OscConfig+0xd8e>
 800c6be:	e0db      	b.n	800c878 <HAL_RCC_OscConfig+0x1038>
 800c6c0:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c6c4:	f5a3 73ea 	sub.w	r3, r3, #468	@ 0x1d4
 800c6c8:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800c6cc:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c6ce:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c6d2:	f5a3 73ea 	sub.w	r3, r3, #468	@ 0x1d4
 800c6d6:	681b      	ldr	r3, [r3, #0]
 800c6d8:	fa93 f2a3 	rbit	r2, r3
 800c6dc:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c6e0:	f5a3 73ec 	sub.w	r3, r3, #472	@ 0x1d8
 800c6e4:	601a      	str	r2, [r3, #0]
  return result;
 800c6e6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c6ea:	f5a3 73ec 	sub.w	r3, r3, #472	@ 0x1d8
 800c6ee:	681b      	ldr	r3, [r3, #0]
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800c6f0:	fab3 f383 	clz	r3, r3
 800c6f4:	b2db      	uxtb	r3, r3
 800c6f6:	f103 5384 	add.w	r3, r3, #276824064	@ 0x10800000
 800c6fa:	f503 1384 	add.w	r3, r3, #1081344	@ 0x108000
 800c6fe:	009b      	lsls	r3, r3, #2
 800c700:	461a      	mov	r2, r3
 800c702:	2300      	movs	r3, #0
 800c704:	6013      	str	r3, [r2, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800c706:	f7fe fa0b 	bl	800ab20 <HAL_GetTick>
 800c70a:	f8c7 0200 	str.w	r0, [r7, #512]	@ 0x200
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800c70e:	e009      	b.n	800c724 <HAL_RCC_OscConfig+0xee4>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800c710:	f7fe fa06 	bl	800ab20 <HAL_GetTick>
 800c714:	4602      	mov	r2, r0
 800c716:	f8d7 3200 	ldr.w	r3, [r7, #512]	@ 0x200
 800c71a:	1ad3      	subs	r3, r2, r3
 800c71c:	2b02      	cmp	r3, #2
 800c71e:	d901      	bls.n	800c724 <HAL_RCC_OscConfig+0xee4>
          {
            return HAL_TIMEOUT;
 800c720:	2303      	movs	r3, #3
 800c722:	e0aa      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
 800c724:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c728:	f5a3 73ee 	sub.w	r3, r3, #476	@ 0x1dc
 800c72c:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c730:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c732:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c736:	f5a3 73ee 	sub.w	r3, r3, #476	@ 0x1dc
 800c73a:	681b      	ldr	r3, [r3, #0]
 800c73c:	fa93 f2a3 	rbit	r2, r3
 800c740:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c744:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
 800c748:	601a      	str	r2, [r3, #0]
  return result;
 800c74a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c74e:	f5a3 73f0 	sub.w	r3, r3, #480	@ 0x1e0
 800c752:	681b      	ldr	r3, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800c754:	fab3 f383 	clz	r3, r3
 800c758:	b2db      	uxtb	r3, r3
 800c75a:	2b3f      	cmp	r3, #63	@ 0x3f
 800c75c:	d802      	bhi.n	800c764 <HAL_RCC_OscConfig+0xf24>
 800c75e:	4b2e      	ldr	r3, [pc, #184]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c760:	681b      	ldr	r3, [r3, #0]
 800c762:	e027      	b.n	800c7b4 <HAL_RCC_OscConfig+0xf74>
 800c764:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c768:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
 800c76c:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c770:	601a      	str	r2, [r3, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c772:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c776:	f5a3 73f2 	sub.w	r3, r3, #484	@ 0x1e4
 800c77a:	681b      	ldr	r3, [r3, #0]
 800c77c:	fa93 f2a3 	rbit	r2, r3
 800c780:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c784:	f5a3 73f4 	sub.w	r3, r3, #488	@ 0x1e8
 800c788:	601a      	str	r2, [r3, #0]
 800c78a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c78e:	f5a3 73f6 	sub.w	r3, r3, #492	@ 0x1ec
 800c792:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c796:	601a      	str	r2, [r3, #0]
 800c798:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c79c:	f5a3 73f6 	sub.w	r3, r3, #492	@ 0x1ec
 800c7a0:	681b      	ldr	r3, [r3, #0]
 800c7a2:	fa93 f2a3 	rbit	r2, r3
 800c7a6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c7aa:	f5a3 73f8 	sub.w	r3, r3, #496	@ 0x1f0
 800c7ae:	601a      	str	r2, [r3, #0]
 800c7b0:	4b19      	ldr	r3, [pc, #100]	@ (800c818 <HAL_RCC_OscConfig+0xfd8>)
 800c7b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c7b4:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c7b8:	f5a2 72fa 	sub.w	r2, r2, #500	@ 0x1f4
 800c7bc:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
 800c7c0:	6011      	str	r1, [r2, #0]
 800c7c2:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c7c6:	f5a2 72fa 	sub.w	r2, r2, #500	@ 0x1f4
 800c7ca:	6812      	ldr	r2, [r2, #0]
 800c7cc:	fa92 f1a2 	rbit	r1, r2
 800c7d0:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c7d4:	f5a2 72fc 	sub.w	r2, r2, #504	@ 0x1f8
 800c7d8:	6011      	str	r1, [r2, #0]
  return result;
 800c7da:	f507 7202 	add.w	r2, r7, #520	@ 0x208
 800c7de:	f5a2 72fc 	sub.w	r2, r2, #504	@ 0x1f8
 800c7e2:	6812      	ldr	r2, [r2, #0]
 800c7e4:	fab2 f282 	clz	r2, r2
 800c7e8:	b2d2      	uxtb	r2, r2
 800c7ea:	f042 0220 	orr.w	r2, r2, #32
 800c7ee:	b2d2      	uxtb	r2, r2
 800c7f0:	f002 021f 	and.w	r2, r2, #31
 800c7f4:	2101      	movs	r1, #1
 800c7f6:	fa01 f202 	lsl.w	r2, r1, r2
 800c7fa:	4013      	ands	r3, r2
 800c7fc:	2b00      	cmp	r3, #0
 800c7fe:	d187      	bne.n	800c710 <HAL_RCC_OscConfig+0xed0>
 800c800:	e03a      	b.n	800c878 <HAL_RCC_OscConfig+0x1038>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800c802:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c806:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c80a:	681b      	ldr	r3, [r3, #0]
 800c80c:	699b      	ldr	r3, [r3, #24]
 800c80e:	2b01      	cmp	r3, #1
 800c810:	d104      	bne.n	800c81c <HAL_RCC_OscConfig+0xfdc>
      {
        return HAL_ERROR;
 800c812:	2301      	movs	r3, #1
 800c814:	e031      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
 800c816:	bf00      	nop
 800c818:	40021000 	.word	0x40021000
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 800c81c:	4b19      	ldr	r3, [pc, #100]	@ (800c884 <HAL_RCC_OscConfig+0x1044>)
 800c81e:	685b      	ldr	r3, [r3, #4]
 800c820:	f8c7 31fc 	str.w	r3, [r7, #508]	@ 0x1fc
#if defined(RCC_CFGR_PLLSRC_HSI_PREDIV)
        pll_config2 = RCC->CFGR2;
 800c824:	4b17      	ldr	r3, [pc, #92]	@ (800c884 <HAL_RCC_OscConfig+0x1044>)
 800c826:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c828:	f8c7 31f8 	str.w	r3, [r7, #504]	@ 0x1f8
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC)   != RCC_OscInitStruct->PLL.PLLSource) ||      
 800c82c:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 800c830:	f403 32c0 	and.w	r2, r3, #98304	@ 0x18000
 800c834:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c838:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c83c:	681b      	ldr	r3, [r3, #0]
 800c83e:	69db      	ldr	r3, [r3, #28]
 800c840:	429a      	cmp	r2, r3
 800c842:	d117      	bne.n	800c874 <HAL_RCC_OscConfig+0x1034>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL)   != RCC_OscInitStruct->PLL.PLLMUL)    ||      
 800c844:	f8d7 31fc 	ldr.w	r3, [r7, #508]	@ 0x1fc
 800c848:	f403 1270 	and.w	r2, r3, #3932160	@ 0x3c0000
 800c84c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c850:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c854:	681b      	ldr	r3, [r3, #0]
 800c856:	6a1b      	ldr	r3, [r3, #32]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC)   != RCC_OscInitStruct->PLL.PLLSource) ||      
 800c858:	429a      	cmp	r2, r3
 800c85a:	d10b      	bne.n	800c874 <HAL_RCC_OscConfig+0x1034>
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV)  != RCC_OscInitStruct->PLL.PREDIV))     
 800c85c:	f8d7 31f8 	ldr.w	r3, [r7, #504]	@ 0x1f8
 800c860:	f003 020f 	and.w	r2, r3, #15
 800c864:	f507 7302 	add.w	r3, r7, #520	@ 0x208
 800c868:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 800c86c:	681b      	ldr	r3, [r3, #0]
 800c86e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL)   != RCC_OscInitStruct->PLL.PLLMUL)    ||      
 800c870:	429a      	cmp	r2, r3
 800c872:	d001      	beq.n	800c878 <HAL_RCC_OscConfig+0x1038>
#else
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC)   != RCC_OscInitStruct->PLL.PLLSource) ||      
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL)   != RCC_OscInitStruct->PLL.PLLMUL))
#endif
        {
          return HAL_ERROR;
 800c874:	2301      	movs	r3, #1
 800c876:	e000      	b.n	800c87a <HAL_RCC_OscConfig+0x103a>
        }
      }
    }
  }

  return HAL_OK;
 800c878:	2300      	movs	r3, #0
}
 800c87a:	4618      	mov	r0, r3
 800c87c:	f507 7702 	add.w	r7, r7, #520	@ 0x208
 800c880:	46bd      	mov	sp, r7
 800c882:	bd80      	pop	{r7, pc}
 800c884:	40021000 	.word	0x40021000

0800c888 <HAL_RCC_ClockConfig>:
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800c888:	b580      	push	{r7, lr}
 800c88a:	b09e      	sub	sp, #120	@ 0x78
 800c88c:	af00      	add	r7, sp, #0
 800c88e:	6078      	str	r0, [r7, #4]
 800c890:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0U;
 800c892:	2300      	movs	r3, #0
 800c894:	677b      	str	r3, [r7, #116]	@ 0x74

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800c896:	687b      	ldr	r3, [r7, #4]
 800c898:	2b00      	cmp	r3, #0
 800c89a:	d101      	bne.n	800c8a0 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
 800c89c:	2301      	movs	r3, #1
 800c89e:	e154      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800c8a0:	4b89      	ldr	r3, [pc, #548]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800c8a2:	681b      	ldr	r3, [r3, #0]
 800c8a4:	f003 0307 	and.w	r3, r3, #7
 800c8a8:	683a      	ldr	r2, [r7, #0]
 800c8aa:	429a      	cmp	r2, r3
 800c8ac:	d910      	bls.n	800c8d0 <HAL_RCC_ClockConfig+0x48>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800c8ae:	4b86      	ldr	r3, [pc, #536]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800c8b0:	681b      	ldr	r3, [r3, #0]
 800c8b2:	f023 0207 	bic.w	r2, r3, #7
 800c8b6:	4984      	ldr	r1, [pc, #528]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800c8b8:	683b      	ldr	r3, [r7, #0]
 800c8ba:	4313      	orrs	r3, r2
 800c8bc:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800c8be:	4b82      	ldr	r3, [pc, #520]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800c8c0:	681b      	ldr	r3, [r3, #0]
 800c8c2:	f003 0307 	and.w	r3, r3, #7
 800c8c6:	683a      	ldr	r2, [r7, #0]
 800c8c8:	429a      	cmp	r2, r3
 800c8ca:	d001      	beq.n	800c8d0 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
 800c8cc:	2301      	movs	r3, #1
 800c8ce:	e13c      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800c8d0:	687b      	ldr	r3, [r7, #4]
 800c8d2:	681b      	ldr	r3, [r3, #0]
 800c8d4:	f003 0302 	and.w	r3, r3, #2
 800c8d8:	2b00      	cmp	r3, #0
 800c8da:	d008      	beq.n	800c8ee <HAL_RCC_ClockConfig+0x66>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800c8dc:	4b7b      	ldr	r3, [pc, #492]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800c8de:	685b      	ldr	r3, [r3, #4]
 800c8e0:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 800c8e4:	687b      	ldr	r3, [r7, #4]
 800c8e6:	689b      	ldr	r3, [r3, #8]
 800c8e8:	4978      	ldr	r1, [pc, #480]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800c8ea:	4313      	orrs	r3, r2
 800c8ec:	604b      	str	r3, [r1, #4]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800c8ee:	687b      	ldr	r3, [r7, #4]
 800c8f0:	681b      	ldr	r3, [r3, #0]
 800c8f2:	f003 0301 	and.w	r3, r3, #1
 800c8f6:	2b00      	cmp	r3, #0
 800c8f8:	f000 80cd 	beq.w	800ca96 <HAL_RCC_ClockConfig+0x20e>
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c8fc:	687b      	ldr	r3, [r7, #4]
 800c8fe:	685b      	ldr	r3, [r3, #4]
 800c900:	2b01      	cmp	r3, #1
 800c902:	d137      	bne.n	800c974 <HAL_RCC_ClockConfig+0xec>
 800c904:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800c908:	66fb      	str	r3, [r7, #108]	@ 0x6c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c90a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c90c:	fa93 f3a3 	rbit	r3, r3
 800c910:	673b      	str	r3, [r7, #112]	@ 0x70
  return result;
 800c912:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800c914:	fab3 f383 	clz	r3, r3
 800c918:	b2db      	uxtb	r3, r3
 800c91a:	2b3f      	cmp	r3, #63	@ 0x3f
 800c91c:	d802      	bhi.n	800c924 <HAL_RCC_ClockConfig+0x9c>
 800c91e:	4b6b      	ldr	r3, [pc, #428]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800c920:	681b      	ldr	r3, [r3, #0]
 800c922:	e00f      	b.n	800c944 <HAL_RCC_ClockConfig+0xbc>
 800c924:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800c928:	66bb      	str	r3, [r7, #104]	@ 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c92a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800c92c:	fa93 f3a3 	rbit	r3, r3
 800c930:	667b      	str	r3, [r7, #100]	@ 0x64
 800c932:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 800c936:	663b      	str	r3, [r7, #96]	@ 0x60
 800c938:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800c93a:	fa93 f3a3 	rbit	r3, r3
 800c93e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 800c940:	4b62      	ldr	r3, [pc, #392]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800c942:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c944:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800c948:	65ba      	str	r2, [r7, #88]	@ 0x58
 800c94a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800c94c:	fa92 f2a2 	rbit	r2, r2
 800c950:	657a      	str	r2, [r7, #84]	@ 0x54
  return result;
 800c952:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800c954:	fab2 f282 	clz	r2, r2
 800c958:	b2d2      	uxtb	r2, r2
 800c95a:	f042 0220 	orr.w	r2, r2, #32
 800c95e:	b2d2      	uxtb	r2, r2
 800c960:	f002 021f 	and.w	r2, r2, #31
 800c964:	2101      	movs	r1, #1
 800c966:	fa01 f202 	lsl.w	r2, r1, r2
 800c96a:	4013      	ands	r3, r2
 800c96c:	2b00      	cmp	r3, #0
 800c96e:	d171      	bne.n	800ca54 <HAL_RCC_ClockConfig+0x1cc>
      {
        return HAL_ERROR;
 800c970:	2301      	movs	r3, #1
 800c972:	e0ea      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800c974:	687b      	ldr	r3, [r7, #4]
 800c976:	685b      	ldr	r3, [r3, #4]
 800c978:	2b02      	cmp	r3, #2
 800c97a:	d137      	bne.n	800c9ec <HAL_RCC_ClockConfig+0x164>
 800c97c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 800c980:	653b      	str	r3, [r7, #80]	@ 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c982:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c984:	fa93 f3a3 	rbit	r3, r3
 800c988:	64fb      	str	r3, [r7, #76]	@ 0x4c
  return result;
 800c98a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800c98c:	fab3 f383 	clz	r3, r3
 800c990:	b2db      	uxtb	r3, r3
 800c992:	2b3f      	cmp	r3, #63	@ 0x3f
 800c994:	d802      	bhi.n	800c99c <HAL_RCC_ClockConfig+0x114>
 800c996:	4b4d      	ldr	r3, [pc, #308]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800c998:	681b      	ldr	r3, [r3, #0]
 800c99a:	e00f      	b.n	800c9bc <HAL_RCC_ClockConfig+0x134>
 800c99c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 800c9a0:	64bb      	str	r3, [r7, #72]	@ 0x48
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c9a2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800c9a4:	fa93 f3a3 	rbit	r3, r3
 800c9a8:	647b      	str	r3, [r7, #68]	@ 0x44
 800c9aa:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 800c9ae:	643b      	str	r3, [r7, #64]	@ 0x40
 800c9b0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800c9b2:	fa93 f3a3 	rbit	r3, r3
 800c9b6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c9b8:	4b44      	ldr	r3, [pc, #272]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800c9ba:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c9bc:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800c9c0:	63ba      	str	r2, [r7, #56]	@ 0x38
 800c9c2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800c9c4:	fa92 f2a2 	rbit	r2, r2
 800c9c8:	637a      	str	r2, [r7, #52]	@ 0x34
  return result;
 800c9ca:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800c9cc:	fab2 f282 	clz	r2, r2
 800c9d0:	b2d2      	uxtb	r2, r2
 800c9d2:	f042 0220 	orr.w	r2, r2, #32
 800c9d6:	b2d2      	uxtb	r2, r2
 800c9d8:	f002 021f 	and.w	r2, r2, #31
 800c9dc:	2101      	movs	r1, #1
 800c9de:	fa01 f202 	lsl.w	r2, r1, r2
 800c9e2:	4013      	ands	r3, r2
 800c9e4:	2b00      	cmp	r3, #0
 800c9e6:	d135      	bne.n	800ca54 <HAL_RCC_ClockConfig+0x1cc>
      {
        return HAL_ERROR;
 800c9e8:	2301      	movs	r3, #1
 800c9ea:	e0ae      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
 800c9ec:	2302      	movs	r3, #2
 800c9ee:	633b      	str	r3, [r7, #48]	@ 0x30
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c9f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800c9f2:	fa93 f3a3 	rbit	r3, r3
 800c9f6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  return result;
 800c9f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800c9fa:	fab3 f383 	clz	r3, r3
 800c9fe:	b2db      	uxtb	r3, r3
 800ca00:	2b3f      	cmp	r3, #63	@ 0x3f
 800ca02:	d802      	bhi.n	800ca0a <HAL_RCC_ClockConfig+0x182>
 800ca04:	4b31      	ldr	r3, [pc, #196]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800ca06:	681b      	ldr	r3, [r3, #0]
 800ca08:	e00d      	b.n	800ca26 <HAL_RCC_ClockConfig+0x19e>
 800ca0a:	2302      	movs	r3, #2
 800ca0c:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800ca0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ca10:	fa93 f3a3 	rbit	r3, r3
 800ca14:	627b      	str	r3, [r7, #36]	@ 0x24
 800ca16:	2302      	movs	r3, #2
 800ca18:	623b      	str	r3, [r7, #32]
 800ca1a:	6a3b      	ldr	r3, [r7, #32]
 800ca1c:	fa93 f3a3 	rbit	r3, r3
 800ca20:	61fb      	str	r3, [r7, #28]
 800ca22:	4b2a      	ldr	r3, [pc, #168]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800ca24:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ca26:	2202      	movs	r2, #2
 800ca28:	61ba      	str	r2, [r7, #24]
 800ca2a:	69ba      	ldr	r2, [r7, #24]
 800ca2c:	fa92 f2a2 	rbit	r2, r2
 800ca30:	617a      	str	r2, [r7, #20]
  return result;
 800ca32:	697a      	ldr	r2, [r7, #20]
 800ca34:	fab2 f282 	clz	r2, r2
 800ca38:	b2d2      	uxtb	r2, r2
 800ca3a:	f042 0220 	orr.w	r2, r2, #32
 800ca3e:	b2d2      	uxtb	r2, r2
 800ca40:	f002 021f 	and.w	r2, r2, #31
 800ca44:	2101      	movs	r1, #1
 800ca46:	fa01 f202 	lsl.w	r2, r1, r2
 800ca4a:	4013      	ands	r3, r2
 800ca4c:	2b00      	cmp	r3, #0
 800ca4e:	d101      	bne.n	800ca54 <HAL_RCC_ClockConfig+0x1cc>
      {
        return HAL_ERROR;
 800ca50:	2301      	movs	r3, #1
 800ca52:	e07a      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800ca54:	4b1d      	ldr	r3, [pc, #116]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800ca56:	685b      	ldr	r3, [r3, #4]
 800ca58:	f023 0203 	bic.w	r2, r3, #3
 800ca5c:	687b      	ldr	r3, [r7, #4]
 800ca5e:	685b      	ldr	r3, [r3, #4]
 800ca60:	491a      	ldr	r1, [pc, #104]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800ca62:	4313      	orrs	r3, r2
 800ca64:	604b      	str	r3, [r1, #4]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800ca66:	f7fe f85b 	bl	800ab20 <HAL_GetTick>
 800ca6a:	6778      	str	r0, [r7, #116]	@ 0x74
    
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800ca6c:	e00a      	b.n	800ca84 <HAL_RCC_ClockConfig+0x1fc>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800ca6e:	f7fe f857 	bl	800ab20 <HAL_GetTick>
 800ca72:	4602      	mov	r2, r0
 800ca74:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800ca76:	1ad3      	subs	r3, r2, r3
 800ca78:	f241 3288 	movw	r2, #5000	@ 0x1388
 800ca7c:	4293      	cmp	r3, r2
 800ca7e:	d901      	bls.n	800ca84 <HAL_RCC_ClockConfig+0x1fc>
      {
        return HAL_TIMEOUT;
 800ca80:	2303      	movs	r3, #3
 800ca82:	e062      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800ca84:	4b11      	ldr	r3, [pc, #68]	@ (800cacc <HAL_RCC_ClockConfig+0x244>)
 800ca86:	685b      	ldr	r3, [r3, #4]
 800ca88:	f003 020c 	and.w	r2, r3, #12
 800ca8c:	687b      	ldr	r3, [r7, #4]
 800ca8e:	685b      	ldr	r3, [r3, #4]
 800ca90:	009b      	lsls	r3, r3, #2
 800ca92:	429a      	cmp	r2, r3
 800ca94:	d1eb      	bne.n	800ca6e <HAL_RCC_ClockConfig+0x1e6>
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800ca96:	4b0c      	ldr	r3, [pc, #48]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800ca98:	681b      	ldr	r3, [r3, #0]
 800ca9a:	f003 0307 	and.w	r3, r3, #7
 800ca9e:	683a      	ldr	r2, [r7, #0]
 800caa0:	429a      	cmp	r2, r3
 800caa2:	d215      	bcs.n	800cad0 <HAL_RCC_ClockConfig+0x248>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800caa4:	4b08      	ldr	r3, [pc, #32]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800caa6:	681b      	ldr	r3, [r3, #0]
 800caa8:	f023 0207 	bic.w	r2, r3, #7
 800caac:	4906      	ldr	r1, [pc, #24]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800caae:	683b      	ldr	r3, [r7, #0]
 800cab0:	4313      	orrs	r3, r2
 800cab2:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800cab4:	4b04      	ldr	r3, [pc, #16]	@ (800cac8 <HAL_RCC_ClockConfig+0x240>)
 800cab6:	681b      	ldr	r3, [r3, #0]
 800cab8:	f003 0307 	and.w	r3, r3, #7
 800cabc:	683a      	ldr	r2, [r7, #0]
 800cabe:	429a      	cmp	r2, r3
 800cac0:	d006      	beq.n	800cad0 <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
 800cac2:	2301      	movs	r3, #1
 800cac4:	e041      	b.n	800cb4a <HAL_RCC_ClockConfig+0x2c2>
 800cac6:	bf00      	nop
 800cac8:	40022000 	.word	0x40022000
 800cacc:	40021000 	.word	0x40021000
    }
  }    

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800cad0:	687b      	ldr	r3, [r7, #4]
 800cad2:	681b      	ldr	r3, [r3, #0]
 800cad4:	f003 0304 	and.w	r3, r3, #4
 800cad8:	2b00      	cmp	r3, #0
 800cada:	d008      	beq.n	800caee <HAL_RCC_ClockConfig+0x266>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800cadc:	4b1d      	ldr	r3, [pc, #116]	@ (800cb54 <HAL_RCC_ClockConfig+0x2cc>)
 800cade:	685b      	ldr	r3, [r3, #4]
 800cae0:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 800cae4:	687b      	ldr	r3, [r7, #4]
 800cae6:	68db      	ldr	r3, [r3, #12]
 800cae8:	491a      	ldr	r1, [pc, #104]	@ (800cb54 <HAL_RCC_ClockConfig+0x2cc>)
 800caea:	4313      	orrs	r3, r2
 800caec:	604b      	str	r3, [r1, #4]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800caee:	687b      	ldr	r3, [r7, #4]
 800caf0:	681b      	ldr	r3, [r3, #0]
 800caf2:	f003 0308 	and.w	r3, r3, #8
 800caf6:	2b00      	cmp	r3, #0
 800caf8:	d009      	beq.n	800cb0e <HAL_RCC_ClockConfig+0x286>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800cafa:	4b16      	ldr	r3, [pc, #88]	@ (800cb54 <HAL_RCC_ClockConfig+0x2cc>)
 800cafc:	685b      	ldr	r3, [r3, #4]
 800cafe:	f423 5260 	bic.w	r2, r3, #14336	@ 0x3800
 800cb02:	687b      	ldr	r3, [r7, #4]
 800cb04:	691b      	ldr	r3, [r3, #16]
 800cb06:	00db      	lsls	r3, r3, #3
 800cb08:	4912      	ldr	r1, [pc, #72]	@ (800cb54 <HAL_RCC_ClockConfig+0x2cc>)
 800cb0a:	4313      	orrs	r3, r2
 800cb0c:	604b      	str	r3, [r1, #4]
  }
 
  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 800cb0e:	f000 f829 	bl	800cb64 <HAL_RCC_GetSysClockFreq>
 800cb12:	4601      	mov	r1, r0
 800cb14:	4b0f      	ldr	r3, [pc, #60]	@ (800cb54 <HAL_RCC_ClockConfig+0x2cc>)
 800cb16:	685b      	ldr	r3, [r3, #4]
 800cb18:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800cb1c:	22f0      	movs	r2, #240	@ 0xf0
 800cb1e:	613a      	str	r2, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cb20:	693a      	ldr	r2, [r7, #16]
 800cb22:	fa92 f2a2 	rbit	r2, r2
 800cb26:	60fa      	str	r2, [r7, #12]
  return result;
 800cb28:	68fa      	ldr	r2, [r7, #12]
 800cb2a:	fab2 f282 	clz	r2, r2
 800cb2e:	b2d2      	uxtb	r2, r2
 800cb30:	40d3      	lsrs	r3, r2
 800cb32:	4a09      	ldr	r2, [pc, #36]	@ (800cb58 <HAL_RCC_ClockConfig+0x2d0>)
 800cb34:	5cd3      	ldrb	r3, [r2, r3]
 800cb36:	fa21 f303 	lsr.w	r3, r1, r3
 800cb3a:	4a08      	ldr	r2, [pc, #32]	@ (800cb5c <HAL_RCC_ClockConfig+0x2d4>)
 800cb3c:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (uwTickPrio);
 800cb3e:	4b08      	ldr	r3, [pc, #32]	@ (800cb60 <HAL_RCC_ClockConfig+0x2d8>)
 800cb40:	681b      	ldr	r3, [r3, #0]
 800cb42:	4618      	mov	r0, r3
 800cb44:	f7fd ffa8 	bl	800aa98 <HAL_InitTick>
  
  return HAL_OK;
 800cb48:	2300      	movs	r3, #0
}
 800cb4a:	4618      	mov	r0, r3
 800cb4c:	3778      	adds	r7, #120	@ 0x78
 800cb4e:	46bd      	mov	sp, r7
 800cb50:	bd80      	pop	{r7, pc}
 800cb52:	bf00      	nop
 800cb54:	40021000 	.word	0x40021000
 800cb58:	0800d134 	.word	0x0800d134
 800cb5c:	20000000 	.word	0x20000000
 800cb60:	20000004 	.word	0x20000004

0800cb64 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800cb64:	b480      	push	{r7}
 800cb66:	b087      	sub	sp, #28
 800cb68:	af00      	add	r7, sp, #0
  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
 800cb6a:	2300      	movs	r3, #0
 800cb6c:	60fb      	str	r3, [r7, #12]
 800cb6e:	2300      	movs	r3, #0
 800cb70:	60bb      	str	r3, [r7, #8]
 800cb72:	2300      	movs	r3, #0
 800cb74:	617b      	str	r3, [r7, #20]
 800cb76:	2300      	movs	r3, #0
 800cb78:	607b      	str	r3, [r7, #4]
  uint32_t sysclockfreq = 0U;
 800cb7a:	2300      	movs	r3, #0
 800cb7c:	613b      	str	r3, [r7, #16]
  
  tmpreg = RCC->CFGR;
 800cb7e:	4b1f      	ldr	r3, [pc, #124]	@ (800cbfc <HAL_RCC_GetSysClockFreq+0x98>)
 800cb80:	685b      	ldr	r3, [r3, #4]
 800cb82:	60fb      	str	r3, [r7, #12]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800cb84:	68fb      	ldr	r3, [r7, #12]
 800cb86:	f003 030c 	and.w	r3, r3, #12
 800cb8a:	2b04      	cmp	r3, #4
 800cb8c:	d002      	beq.n	800cb94 <HAL_RCC_GetSysClockFreq+0x30>
 800cb8e:	2b08      	cmp	r3, #8
 800cb90:	d003      	beq.n	800cb9a <HAL_RCC_GetSysClockFreq+0x36>
 800cb92:	e029      	b.n	800cbe8 <HAL_RCC_GetSysClockFreq+0x84>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 800cb94:	4b1a      	ldr	r3, [pc, #104]	@ (800cc00 <HAL_RCC_GetSysClockFreq+0x9c>)
 800cb96:	613b      	str	r3, [r7, #16]
      break;
 800cb98:	e029      	b.n	800cbee <HAL_RCC_GetSysClockFreq+0x8a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 800cb9a:	68fb      	ldr	r3, [r7, #12]
 800cb9c:	0c9b      	lsrs	r3, r3, #18
 800cb9e:	f003 030f 	and.w	r3, r3, #15
 800cba2:	4a18      	ldr	r2, [pc, #96]	@ (800cc04 <HAL_RCC_GetSysClockFreq+0xa0>)
 800cba4:	5cd3      	ldrb	r3, [r2, r3]
 800cba6:	607b      	str	r3, [r7, #4]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_Pos];
 800cba8:	4b14      	ldr	r3, [pc, #80]	@ (800cbfc <HAL_RCC_GetSysClockFreq+0x98>)
 800cbaa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cbac:	f003 030f 	and.w	r3, r3, #15
 800cbb0:	4a15      	ldr	r2, [pc, #84]	@ (800cc08 <HAL_RCC_GetSysClockFreq+0xa4>)
 800cbb2:	5cd3      	ldrb	r3, [r2, r3]
 800cbb4:	60bb      	str	r3, [r7, #8]
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
      }
#else
      if ((tmpreg & RCC_CFGR_PLLSRC_HSE_PREDIV) == RCC_CFGR_PLLSRC_HSE_PREDIV)
 800cbb6:	68fb      	ldr	r3, [r7, #12]
 800cbb8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800cbbc:	2b00      	cmp	r3, #0
 800cbbe:	d008      	beq.n	800cbd2 <HAL_RCC_GetSysClockFreq+0x6e>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSE_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 800cbc0:	4a0f      	ldr	r2, [pc, #60]	@ (800cc00 <HAL_RCC_GetSysClockFreq+0x9c>)
 800cbc2:	68bb      	ldr	r3, [r7, #8]
 800cbc4:	fbb2 f2f3 	udiv	r2, r2, r3
 800cbc8:	687b      	ldr	r3, [r7, #4]
 800cbca:	fb02 f303 	mul.w	r3, r2, r3
 800cbce:	617b      	str	r3, [r7, #20]
 800cbd0:	e007      	b.n	800cbe2 <HAL_RCC_GetSysClockFreq+0x7e>
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSI_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 800cbd2:	4a0b      	ldr	r2, [pc, #44]	@ (800cc00 <HAL_RCC_GetSysClockFreq+0x9c>)
 800cbd4:	68bb      	ldr	r3, [r7, #8]
 800cbd6:	fbb2 f2f3 	udiv	r2, r2, r3
 800cbda:	687b      	ldr	r3, [r7, #4]
 800cbdc:	fb02 f303 	mul.w	r3, r2, r3
 800cbe0:	617b      	str	r3, [r7, #20]
      }
#endif /* RCC_CFGR_PLLSRC_HSI_DIV2 */
      sysclockfreq = pllclk;
 800cbe2:	697b      	ldr	r3, [r7, #20]
 800cbe4:	613b      	str	r3, [r7, #16]
      break;
 800cbe6:	e002      	b.n	800cbee <HAL_RCC_GetSysClockFreq+0x8a>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    default: /* HSI used as system clock */
    {
      sysclockfreq = HSI_VALUE;
 800cbe8:	4b05      	ldr	r3, [pc, #20]	@ (800cc00 <HAL_RCC_GetSysClockFreq+0x9c>)
 800cbea:	613b      	str	r3, [r7, #16]
      break;
 800cbec:	bf00      	nop
    }
  }
  return sysclockfreq;
 800cbee:	693b      	ldr	r3, [r7, #16]
}
 800cbf0:	4618      	mov	r0, r3
 800cbf2:	371c      	adds	r7, #28
 800cbf4:	46bd      	mov	sp, r7
 800cbf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbfa:	4770      	bx	lr
 800cbfc:	40021000 	.word	0x40021000
 800cc00:	007a1200 	.word	0x007a1200
 800cc04:	0800d14c 	.word	0x0800d14c
 800cc08:	0800d15c 	.word	0x0800d15c

0800cc0c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800cc0c:	b480      	push	{r7}
 800cc0e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800cc10:	4b03      	ldr	r3, [pc, #12]	@ (800cc20 <HAL_RCC_GetHCLKFreq+0x14>)
 800cc12:	681b      	ldr	r3, [r3, #0]
}
 800cc14:	4618      	mov	r0, r3
 800cc16:	46bd      	mov	sp, r7
 800cc18:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc1c:	4770      	bx	lr
 800cc1e:	bf00      	nop
 800cc20:	20000000 	.word	0x20000000

0800cc24 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800cc24:	b580      	push	{r7, lr}
 800cc26:	b082      	sub	sp, #8
 800cc28:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
 800cc2a:	f7ff ffef 	bl	800cc0c <HAL_RCC_GetHCLKFreq>
 800cc2e:	4601      	mov	r1, r0
 800cc30:	4b0b      	ldr	r3, [pc, #44]	@ (800cc60 <HAL_RCC_GetPCLK1Freq+0x3c>)
 800cc32:	685b      	ldr	r3, [r3, #4]
 800cc34:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 800cc38:	f44f 62e0 	mov.w	r2, #1792	@ 0x700
 800cc3c:	607a      	str	r2, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cc3e:	687a      	ldr	r2, [r7, #4]
 800cc40:	fa92 f2a2 	rbit	r2, r2
 800cc44:	603a      	str	r2, [r7, #0]
  return result;
 800cc46:	683a      	ldr	r2, [r7, #0]
 800cc48:	fab2 f282 	clz	r2, r2
 800cc4c:	b2d2      	uxtb	r2, r2
 800cc4e:	40d3      	lsrs	r3, r2
 800cc50:	4a04      	ldr	r2, [pc, #16]	@ (800cc64 <HAL_RCC_GetPCLK1Freq+0x40>)
 800cc52:	5cd3      	ldrb	r3, [r2, r3]
 800cc54:	fa21 f303 	lsr.w	r3, r1, r3
}    
 800cc58:	4618      	mov	r0, r3
 800cc5a:	3708      	adds	r7, #8
 800cc5c:	46bd      	mov	sp, r7
 800cc5e:	bd80      	pop	{r7, pc}
 800cc60:	40021000 	.word	0x40021000
 800cc64:	0800d144 	.word	0x0800d144

0800cc68 <HAL_RCCEx_PeriphCLKConfig>:
  *         When the TIMx clock source is PLL clock, so the TIMx clock is PLL clock x 2.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800cc68:	b580      	push	{r7, lr}
 800cc6a:	b092      	sub	sp, #72	@ 0x48
 800cc6c:	af00      	add	r7, sp, #0
 800cc6e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 800cc70:	2300      	movs	r3, #0
 800cc72:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t temp_reg = 0U;
 800cc74:	2300      	movs	r3, #0
 800cc76:	63fb      	str	r3, [r7, #60]	@ 0x3c
  FlagStatus       pwrclkchanged = RESET;
 800cc78:	2300      	movs	r3, #0
 800cc7a:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800cc7e:	687b      	ldr	r3, [r7, #4]
 800cc80:	681b      	ldr	r3, [r3, #0]
 800cc82:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800cc86:	2b00      	cmp	r3, #0
 800cc88:	f000 80d2 	beq.w	800ce30 <HAL_RCCEx_PeriphCLKConfig+0x1c8>


    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800cc8c:	4b4d      	ldr	r3, [pc, #308]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cc8e:	69db      	ldr	r3, [r3, #28]
 800cc90:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800cc94:	2b00      	cmp	r3, #0
 800cc96:	d10e      	bne.n	800ccb6 <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800cc98:	4b4a      	ldr	r3, [pc, #296]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cc9a:	69db      	ldr	r3, [r3, #28]
 800cc9c:	4a49      	ldr	r2, [pc, #292]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cc9e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800cca2:	61d3      	str	r3, [r2, #28]
 800cca4:	4b47      	ldr	r3, [pc, #284]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cca6:	69db      	ldr	r3, [r3, #28]
 800cca8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800ccac:	60bb      	str	r3, [r7, #8]
 800ccae:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800ccb0:	2301      	movs	r3, #1
 800ccb2:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800ccb6:	4b44      	ldr	r3, [pc, #272]	@ (800cdc8 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 800ccb8:	681b      	ldr	r3, [r3, #0]
 800ccba:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800ccbe:	2b00      	cmp	r3, #0
 800ccc0:	d118      	bne.n	800ccf4 <HAL_RCCEx_PeriphCLKConfig+0x8c>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800ccc2:	4b41      	ldr	r3, [pc, #260]	@ (800cdc8 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 800ccc4:	681b      	ldr	r3, [r3, #0]
 800ccc6:	4a40      	ldr	r2, [pc, #256]	@ (800cdc8 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 800ccc8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800cccc:	6013      	str	r3, [r2, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800ccce:	f7fd ff27 	bl	800ab20 <HAL_GetTick>
 800ccd2:	6438      	str	r0, [r7, #64]	@ 0x40
      
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800ccd4:	e008      	b.n	800cce8 <HAL_RCCEx_PeriphCLKConfig+0x80>
      {
          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800ccd6:	f7fd ff23 	bl	800ab20 <HAL_GetTick>
 800ccda:	4602      	mov	r2, r0
 800ccdc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ccde:	1ad3      	subs	r3, r2, r3
 800cce0:	2b64      	cmp	r3, #100	@ 0x64
 800cce2:	d901      	bls.n	800cce8 <HAL_RCCEx_PeriphCLKConfig+0x80>
        {
          return HAL_TIMEOUT;
 800cce4:	2303      	movs	r3, #3
 800cce6:	e1d4      	b.n	800d092 <HAL_RCCEx_PeriphCLKConfig+0x42a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800cce8:	4b37      	ldr	r3, [pc, #220]	@ (800cdc8 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 800ccea:	681b      	ldr	r3, [r3, #0]
 800ccec:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800ccf0:	2b00      	cmp	r3, #0
 800ccf2:	d0f0      	beq.n	800ccd6 <HAL_RCCEx_PeriphCLKConfig+0x6e>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800ccf4:	4b33      	ldr	r3, [pc, #204]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800ccf6:	6a1b      	ldr	r3, [r3, #32]
 800ccf8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800ccfc:	63fb      	str	r3, [r7, #60]	@ 0x3c
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800ccfe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800cd00:	2b00      	cmp	r3, #0
 800cd02:	f000 8082 	beq.w	800ce0a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
 800cd06:	687b      	ldr	r3, [r7, #4]
 800cd08:	685b      	ldr	r3, [r3, #4]
 800cd0a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800cd0e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800cd10:	429a      	cmp	r2, r3
 800cd12:	d07a      	beq.n	800ce0a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800cd14:	4b2b      	ldr	r3, [pc, #172]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cd16:	6a1b      	ldr	r3, [r3, #32]
 800cd18:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800cd1c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800cd1e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800cd22:	633b      	str	r3, [r7, #48]	@ 0x30
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cd24:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800cd26:	fa93 f3a3 	rbit	r3, r3
 800cd2a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  return result;
 800cd2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800cd2e:	fab3 f383 	clz	r3, r3
 800cd32:	b2db      	uxtb	r3, r3
 800cd34:	461a      	mov	r2, r3
 800cd36:	4b25      	ldr	r3, [pc, #148]	@ (800cdcc <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800cd38:	4413      	add	r3, r2
 800cd3a:	009b      	lsls	r3, r3, #2
 800cd3c:	461a      	mov	r2, r3
 800cd3e:	2301      	movs	r3, #1
 800cd40:	6013      	str	r3, [r2, #0]
 800cd42:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 800cd46:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cd48:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800cd4a:	fa93 f3a3 	rbit	r3, r3
 800cd4e:	637b      	str	r3, [r7, #52]	@ 0x34
  return result;
 800cd50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
      __HAL_RCC_BACKUPRESET_RELEASE();
 800cd52:	fab3 f383 	clz	r3, r3
 800cd56:	b2db      	uxtb	r3, r3
 800cd58:	461a      	mov	r2, r3
 800cd5a:	4b1c      	ldr	r3, [pc, #112]	@ (800cdcc <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800cd5c:	4413      	add	r3, r2
 800cd5e:	009b      	lsls	r3, r3, #2
 800cd60:	461a      	mov	r2, r3
 800cd62:	2300      	movs	r3, #0
 800cd64:	6013      	str	r3, [r2, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 800cd66:	4a17      	ldr	r2, [pc, #92]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cd68:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800cd6a:	6213      	str	r3, [r2, #32]
    
      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 800cd6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800cd6e:	f003 0301 	and.w	r3, r3, #1
 800cd72:	2b00      	cmp	r3, #0
 800cd74:	d049      	beq.n	800ce0a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800cd76:	f7fd fed3 	bl	800ab20 <HAL_GetTick>
 800cd7a:	6438      	str	r0, [r7, #64]	@ 0x40
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800cd7c:	e00a      	b.n	800cd94 <HAL_RCCEx_PeriphCLKConfig+0x12c>
        {
            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800cd7e:	f7fd fecf 	bl	800ab20 <HAL_GetTick>
 800cd82:	4602      	mov	r2, r0
 800cd84:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800cd86:	1ad3      	subs	r3, r2, r3
 800cd88:	f241 3288 	movw	r2, #5000	@ 0x1388
 800cd8c:	4293      	cmp	r3, r2
 800cd8e:	d901      	bls.n	800cd94 <HAL_RCCEx_PeriphCLKConfig+0x12c>
          {
            return HAL_TIMEOUT;
 800cd90:	2303      	movs	r3, #3
 800cd92:	e17e      	b.n	800d092 <HAL_RCCEx_PeriphCLKConfig+0x42a>
 800cd94:	2302      	movs	r3, #2
 800cd96:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cd98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800cd9a:	fa93 f3a3 	rbit	r3, r3
 800cd9e:	627b      	str	r3, [r7, #36]	@ 0x24
 800cda0:	2302      	movs	r3, #2
 800cda2:	623b      	str	r3, [r7, #32]
 800cda4:	6a3b      	ldr	r3, [r7, #32]
 800cda6:	fa93 f3a3 	rbit	r3, r3
 800cdaa:	61fb      	str	r3, [r7, #28]
  return result;
 800cdac:	69fb      	ldr	r3, [r7, #28]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800cdae:	fab3 f383 	clz	r3, r3
 800cdb2:	b2db      	uxtb	r3, r3
 800cdb4:	f023 035f 	bic.w	r3, r3, #95	@ 0x5f
 800cdb8:	b2db      	uxtb	r3, r3
 800cdba:	2b00      	cmp	r3, #0
 800cdbc:	d108      	bne.n	800cdd0 <HAL_RCCEx_PeriphCLKConfig+0x168>
 800cdbe:	4b01      	ldr	r3, [pc, #4]	@ (800cdc4 <HAL_RCCEx_PeriphCLKConfig+0x15c>)
 800cdc0:	6a1b      	ldr	r3, [r3, #32]
 800cdc2:	e00d      	b.n	800cde0 <HAL_RCCEx_PeriphCLKConfig+0x178>
 800cdc4:	40021000 	.word	0x40021000
 800cdc8:	40007000 	.word	0x40007000
 800cdcc:	10908100 	.word	0x10908100
 800cdd0:	2302      	movs	r3, #2
 800cdd2:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800cdd4:	69bb      	ldr	r3, [r7, #24]
 800cdd6:	fa93 f3a3 	rbit	r3, r3
 800cdda:	617b      	str	r3, [r7, #20]
 800cddc:	4b9a      	ldr	r3, [pc, #616]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cdde:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800cde0:	2202      	movs	r2, #2
 800cde2:	613a      	str	r2, [r7, #16]
 800cde4:	693a      	ldr	r2, [r7, #16]
 800cde6:	fa92 f2a2 	rbit	r2, r2
 800cdea:	60fa      	str	r2, [r7, #12]
  return result;
 800cdec:	68fa      	ldr	r2, [r7, #12]
 800cdee:	fab2 f282 	clz	r2, r2
 800cdf2:	b2d2      	uxtb	r2, r2
 800cdf4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800cdf8:	b2d2      	uxtb	r2, r2
 800cdfa:	f002 021f 	and.w	r2, r2, #31
 800cdfe:	2101      	movs	r1, #1
 800ce00:	fa01 f202 	lsl.w	r2, r1, r2
 800ce04:	4013      	ands	r3, r2
 800ce06:	2b00      	cmp	r3, #0
 800ce08:	d0b9      	beq.n	800cd7e <HAL_RCCEx_PeriphCLKConfig+0x116>
          }      
        }  
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 800ce0a:	4b8f      	ldr	r3, [pc, #572]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce0c:	6a1b      	ldr	r3, [r3, #32]
 800ce0e:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 800ce12:	687b      	ldr	r3, [r7, #4]
 800ce14:	685b      	ldr	r3, [r3, #4]
 800ce16:	498c      	ldr	r1, [pc, #560]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce18:	4313      	orrs	r3, r2
 800ce1a:	620b      	str	r3, [r1, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800ce1c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 800ce20:	2b01      	cmp	r3, #1
 800ce22:	d105      	bne.n	800ce30 <HAL_RCCEx_PeriphCLKConfig+0x1c8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800ce24:	4b88      	ldr	r3, [pc, #544]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce26:	69db      	ldr	r3, [r3, #28]
 800ce28:	4a87      	ldr	r2, [pc, #540]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce2a:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800ce2e:	61d3      	str	r3, [r2, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800ce30:	687b      	ldr	r3, [r7, #4]
 800ce32:	681b      	ldr	r3, [r3, #0]
 800ce34:	f003 0301 	and.w	r3, r3, #1
 800ce38:	2b00      	cmp	r3, #0
 800ce3a:	d008      	beq.n	800ce4e <HAL_RCCEx_PeriphCLKConfig+0x1e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800ce3c:	4b82      	ldr	r3, [pc, #520]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce3e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ce40:	f023 0203 	bic.w	r2, r3, #3
 800ce44:	687b      	ldr	r3, [r7, #4]
 800ce46:	689b      	ldr	r3, [r3, #8]
 800ce48:	497f      	ldr	r1, [pc, #508]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce4a:	4313      	orrs	r3, r2
 800ce4c:	630b      	str	r3, [r1, #48]	@ 0x30
  }

#if defined(RCC_CFGR3_USART2SW)
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800ce4e:	687b      	ldr	r3, [r7, #4]
 800ce50:	681b      	ldr	r3, [r3, #0]
 800ce52:	f003 0302 	and.w	r3, r3, #2
 800ce56:	2b00      	cmp	r3, #0
 800ce58:	d008      	beq.n	800ce6c <HAL_RCCEx_PeriphCLKConfig+0x204>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800ce5a:	4b7b      	ldr	r3, [pc, #492]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce5c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ce5e:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
 800ce62:	687b      	ldr	r3, [r7, #4]
 800ce64:	68db      	ldr	r3, [r3, #12]
 800ce66:	4978      	ldr	r1, [pc, #480]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce68:	4313      	orrs	r3, r2
 800ce6a:	630b      	str	r3, [r1, #48]	@ 0x30
  }
#endif /* RCC_CFGR3_USART2SW */

#if defined(RCC_CFGR3_USART3SW)
  /*------------------------------ USART3 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800ce6c:	687b      	ldr	r3, [r7, #4]
 800ce6e:	681b      	ldr	r3, [r3, #0]
 800ce70:	f003 0304 	and.w	r3, r3, #4
 800ce74:	2b00      	cmp	r3, #0
 800ce76:	d008      	beq.n	800ce8a <HAL_RCCEx_PeriphCLKConfig+0x222>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800ce78:	4b73      	ldr	r3, [pc, #460]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce7a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ce7c:	f423 2240 	bic.w	r2, r3, #786432	@ 0xc0000
 800ce80:	687b      	ldr	r3, [r7, #4]
 800ce82:	691b      	ldr	r3, [r3, #16]
 800ce84:	4970      	ldr	r1, [pc, #448]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce86:	4313      	orrs	r3, r2
 800ce88:	630b      	str	r3, [r1, #48]	@ 0x30
  }
#endif /* RCC_CFGR3_USART3SW */

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800ce8a:	687b      	ldr	r3, [r7, #4]
 800ce8c:	681b      	ldr	r3, [r3, #0]
 800ce8e:	f003 0320 	and.w	r3, r3, #32
 800ce92:	2b00      	cmp	r3, #0
 800ce94:	d008      	beq.n	800cea8 <HAL_RCCEx_PeriphCLKConfig+0x240>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800ce96:	4b6c      	ldr	r3, [pc, #432]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ce98:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ce9a:	f023 0210 	bic.w	r2, r3, #16
 800ce9e:	687b      	ldr	r3, [r7, #4]
 800cea0:	69db      	ldr	r3, [r3, #28]
 800cea2:	4969      	ldr	r1, [pc, #420]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cea4:	4313      	orrs	r3, r2
 800cea6:	630b      	str	r3, [r1, #48]	@ 0x30
#if defined(STM32F302xE) || defined(STM32F303xE)\
 || defined(STM32F302xC) || defined(STM32F303xC)\
 || defined(STM32F302x8)                        \
 || defined(STM32F373xC)
  /*------------------------------ USB Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800cea8:	687b      	ldr	r3, [r7, #4]
 800ceaa:	681b      	ldr	r3, [r3, #0]
 800ceac:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800ceb0:	2b00      	cmp	r3, #0
 800ceb2:	d008      	beq.n	800cec6 <HAL_RCCEx_PeriphCLKConfig+0x25e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->USBClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->USBClockSelection);
 800ceb4:	4b64      	ldr	r3, [pc, #400]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ceb6:	685b      	ldr	r3, [r3, #4]
 800ceb8:	f423 0280 	bic.w	r2, r3, #4194304	@ 0x400000
 800cebc:	687b      	ldr	r3, [r7, #4]
 800cebe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800cec0:	4961      	ldr	r1, [pc, #388]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cec2:	4313      	orrs	r3, r2
 800cec4:	604b      	str	r3, [r1, #4]
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)\
 || defined(STM32F373xC) || defined(STM32F378xx)

  /*------------------------------ I2C2 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800cec6:	687b      	ldr	r3, [r7, #4]
 800cec8:	681b      	ldr	r3, [r3, #0]
 800ceca:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800cece:	2b00      	cmp	r3, #0
 800ced0:	d008      	beq.n	800cee4 <HAL_RCCEx_PeriphCLKConfig+0x27c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800ced2:	4b5d      	ldr	r3, [pc, #372]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800ced4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ced6:	f023 0220 	bic.w	r2, r3, #32
 800ceda:	687b      	ldr	r3, [r7, #4]
 800cedc:	6a1b      	ldr	r3, [r3, #32]
 800cede:	495a      	ldr	r1, [pc, #360]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cee0:	4313      	orrs	r3, r2
 800cee2:	630b      	str	r3, [r1, #48]	@ 0x30
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)

  /*------------------------------ I2C3 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800cee4:	687b      	ldr	r3, [r7, #4]
 800cee6:	681b      	ldr	r3, [r3, #0]
 800cee8:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800ceec:	2b00      	cmp	r3, #0
 800ceee:	d008      	beq.n	800cf02 <HAL_RCCEx_PeriphCLKConfig+0x29a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800cef0:	4b55      	ldr	r3, [pc, #340]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cef2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cef4:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
 800cef8:	687b      	ldr	r3, [r7, #4]
 800cefa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800cefc:	4952      	ldr	r1, [pc, #328]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cefe:	4313      	orrs	r3, r2
 800cf00:	630b      	str	r3, [r1, #48]	@ 0x30
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ UART4 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800cf02:	687b      	ldr	r3, [r7, #4]
 800cf04:	681b      	ldr	r3, [r3, #0]
 800cf06:	f003 0308 	and.w	r3, r3, #8
 800cf0a:	2b00      	cmp	r3, #0
 800cf0c:	d008      	beq.n	800cf20 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800cf0e:	4b4e      	ldr	r3, [pc, #312]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf10:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cf12:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 800cf16:	687b      	ldr	r3, [r7, #4]
 800cf18:	695b      	ldr	r3, [r3, #20]
 800cf1a:	494b      	ldr	r1, [pc, #300]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf1c:	4313      	orrs	r3, r2
 800cf1e:	630b      	str	r3, [r1, #48]	@ 0x30
  }

  /*------------------------------ UART5 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800cf20:	687b      	ldr	r3, [r7, #4]
 800cf22:	681b      	ldr	r3, [r3, #0]
 800cf24:	f003 0310 	and.w	r3, r3, #16
 800cf28:	2b00      	cmp	r3, #0
 800cf2a:	d008      	beq.n	800cf3e <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 800cf2c:	4b46      	ldr	r3, [pc, #280]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf2e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cf30:	f423 0240 	bic.w	r2, r3, #12582912	@ 0xc00000
 800cf34:	687b      	ldr	r3, [r7, #4]
 800cf36:	699b      	ldr	r3, [r3, #24]
 800cf38:	4943      	ldr	r1, [pc, #268]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf3a:	4313      	orrs	r3, r2
 800cf3c:	630b      	str	r3, [r1, #48]	@ 0x30

#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)
  /*------------------------------ I2S Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 800cf3e:	687b      	ldr	r3, [r7, #4]
 800cf40:	681b      	ldr	r3, [r3, #0]
 800cf42:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800cf46:	2b00      	cmp	r3, #0
 800cf48:	d008      	beq.n	800cf5c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure the I2S clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800cf4a:	4b3f      	ldr	r3, [pc, #252]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf4c:	685b      	ldr	r3, [r3, #4]
 800cf4e:	f423 0200 	bic.w	r2, r3, #8388608	@ 0x800000
 800cf52:	687b      	ldr	r3, [r7, #4]
 800cf54:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cf56:	493c      	ldr	r1, [pc, #240]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf58:	4313      	orrs	r3, r2
 800cf5a:	604b      	str	r3, [r1, #4]
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)
      
  /*------------------------------ ADC1 & ADC2 clock Configuration -------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 800cf5c:	687b      	ldr	r3, [r7, #4]
 800cf5e:	681b      	ldr	r3, [r3, #0]
 800cf60:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800cf64:	2b00      	cmp	r3, #0
 800cf66:	d008      	beq.n	800cf7a <HAL_RCCEx_PeriphCLKConfig+0x312>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12PLLCLK_DIV(PeriphClkInit->Adc12ClockSelection));
    
    /* Configure the ADC12 clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 800cf68:	4b37      	ldr	r3, [pc, #220]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf6a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf6c:	f423 72f8 	bic.w	r2, r3, #496	@ 0x1f0
 800cf70:	687b      	ldr	r3, [r7, #4]
 800cf72:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800cf74:	4934      	ldr	r1, [pc, #208]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf76:	4313      	orrs	r3, r2
 800cf78:	62cb      	str	r3, [r1, #44]	@ 0x2c
  
#if defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ ADC3 & ADC4 clock Configuration -------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC34) == RCC_PERIPHCLK_ADC34)
 800cf7a:	687b      	ldr	r3, [r7, #4]
 800cf7c:	681b      	ldr	r3, [r3, #0]
 800cf7e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800cf82:	2b00      	cmp	r3, #0
 800cf84:	d008      	beq.n	800cf98 <HAL_RCCEx_PeriphCLKConfig+0x330>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC34PLLCLK_DIV(PeriphClkInit->Adc34ClockSelection));
    
    /* Configure the ADC34 clock source */
    __HAL_RCC_ADC34_CONFIG(PeriphClkInit->Adc34ClockSelection);
 800cf86:	4b30      	ldr	r3, [pc, #192]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf88:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf8a:	f423 5278 	bic.w	r2, r3, #15872	@ 0x3e00
 800cf8e:	687b      	ldr	r3, [r7, #4]
 800cf90:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf92:	492d      	ldr	r1, [pc, #180]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cf94:	4313      	orrs	r3, r2
 800cf96:	62cb      	str	r3, [r1, #44]	@ 0x2c
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)

  /*------------------------------ TIM1 clock Configuration ----------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM1) == RCC_PERIPHCLK_TIM1)
 800cf98:	687b      	ldr	r3, [r7, #4]
 800cf9a:	681b      	ldr	r3, [r3, #0]
 800cf9c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800cfa0:	2b00      	cmp	r3, #0
 800cfa2:	d008      	beq.n	800cfb6 <HAL_RCCEx_PeriphCLKConfig+0x34e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM1CLKSOURCE(PeriphClkInit->Tim1ClockSelection));
    
    /* Configure the TIM1 clock source */
    __HAL_RCC_TIM1_CONFIG(PeriphClkInit->Tim1ClockSelection);
 800cfa4:	4b28      	ldr	r3, [pc, #160]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cfa6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cfa8:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 800cfac:	687b      	ldr	r3, [r7, #4]
 800cfae:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800cfb0:	4925      	ldr	r1, [pc, #148]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cfb2:	4313      	orrs	r3, r2
 800cfb4:	630b      	str	r3, [r1, #48]	@ 0x30
  
#if defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ TIM8 clock Configuration ----------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM8) == RCC_PERIPHCLK_TIM8)
 800cfb6:	687b      	ldr	r3, [r7, #4]
 800cfb8:	681b      	ldr	r3, [r3, #0]
 800cfba:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800cfbe:	2b00      	cmp	r3, #0
 800cfc0:	d008      	beq.n	800cfd4 <HAL_RCCEx_PeriphCLKConfig+0x36c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM8CLKSOURCE(PeriphClkInit->Tim8ClockSelection));
    
    /* Configure the TIM8 clock source */
    __HAL_RCC_TIM8_CONFIG(PeriphClkInit->Tim8ClockSelection);
 800cfc2:	4b21      	ldr	r3, [pc, #132]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cfc4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cfc6:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 800cfca:	687b      	ldr	r3, [r7, #4]
 800cfcc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cfce:	491e      	ldr	r1, [pc, #120]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cfd0:	4313      	orrs	r3, r2
 800cfd2:	630b      	str	r3, [r1, #48]	@ 0x30
#endif /* STM32F373xC || STM32F378xx */
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)
  
  /*------------------------------ TIM2 clock Configuration -------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM2) == RCC_PERIPHCLK_TIM2)
 800cfd4:	687b      	ldr	r3, [r7, #4]
 800cfd6:	681b      	ldr	r3, [r3, #0]
 800cfd8:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800cfdc:	2b00      	cmp	r3, #0
 800cfde:	d008      	beq.n	800cff2 <HAL_RCCEx_PeriphCLKConfig+0x38a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM2CLKSOURCE(PeriphClkInit->Tim2ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM2_CONFIG(PeriphClkInit->Tim2ClockSelection);
 800cfe0:	4b19      	ldr	r3, [pc, #100]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cfe2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cfe4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
 800cfe8:	687b      	ldr	r3, [r7, #4]
 800cfea:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800cfec:	4916      	ldr	r1, [pc, #88]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800cfee:	4313      	orrs	r3, r2
 800cff0:	630b      	str	r3, [r1, #48]	@ 0x30
  }

  /*------------------------------ TIM3 clock Configuration -------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM34) == RCC_PERIPHCLK_TIM34)
 800cff2:	687b      	ldr	r3, [r7, #4]
 800cff4:	681b      	ldr	r3, [r3, #0]
 800cff6:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800cffa:	2b00      	cmp	r3, #0
 800cffc:	d008      	beq.n	800d010 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM3CLKSOURCE(PeriphClkInit->Tim34ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM34_CONFIG(PeriphClkInit->Tim34ClockSelection);
 800cffe:	4b12      	ldr	r3, [pc, #72]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800d000:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800d002:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
 800d006:	687b      	ldr	r3, [r7, #4]
 800d008:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d00a:	490f      	ldr	r1, [pc, #60]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800d00c:	4313      	orrs	r3, r2
 800d00e:	630b      	str	r3, [r1, #48]	@ 0x30
  }

  /*------------------------------ TIM15 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM15) == RCC_PERIPHCLK_TIM15)
 800d010:	687b      	ldr	r3, [r7, #4]
 800d012:	681b      	ldr	r3, [r3, #0]
 800d014:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800d018:	2b00      	cmp	r3, #0
 800d01a:	d008      	beq.n	800d02e <HAL_RCCEx_PeriphCLKConfig+0x3c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM15CLKSOURCE(PeriphClkInit->Tim15ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM15_CONFIG(PeriphClkInit->Tim15ClockSelection);
 800d01c:	4b0a      	ldr	r3, [pc, #40]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800d01e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800d020:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
 800d024:	687b      	ldr	r3, [r7, #4]
 800d026:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d028:	4907      	ldr	r1, [pc, #28]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800d02a:	4313      	orrs	r3, r2
 800d02c:	630b      	str	r3, [r1, #48]	@ 0x30
  }

  /*------------------------------ TIM16 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM16) == RCC_PERIPHCLK_TIM16)
 800d02e:	687b      	ldr	r3, [r7, #4]
 800d030:	681b      	ldr	r3, [r3, #0]
 800d032:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800d036:	2b00      	cmp	r3, #0
 800d038:	d00c      	beq.n	800d054 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM16CLKSOURCE(PeriphClkInit->Tim16ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM16_CONFIG(PeriphClkInit->Tim16ClockSelection);
 800d03a:	4b03      	ldr	r3, [pc, #12]	@ (800d048 <HAL_RCCEx_PeriphCLKConfig+0x3e0>)
 800d03c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800d03e:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 800d042:	687b      	ldr	r3, [r7, #4]
 800d044:	e002      	b.n	800d04c <HAL_RCCEx_PeriphCLKConfig+0x3e4>
 800d046:	bf00      	nop
 800d048:	40021000 	.word	0x40021000
 800d04c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800d04e:	4913      	ldr	r1, [pc, #76]	@ (800d09c <HAL_RCCEx_PeriphCLKConfig+0x434>)
 800d050:	4313      	orrs	r3, r2
 800d052:	630b      	str	r3, [r1, #48]	@ 0x30
  }

  /*------------------------------ TIM17 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM17) == RCC_PERIPHCLK_TIM17)
 800d054:	687b      	ldr	r3, [r7, #4]
 800d056:	681b      	ldr	r3, [r3, #0]
 800d058:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 800d05c:	2b00      	cmp	r3, #0
 800d05e:	d008      	beq.n	800d072 <HAL_RCCEx_PeriphCLKConfig+0x40a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM17CLKSOURCE(PeriphClkInit->Tim17ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM17_CONFIG(PeriphClkInit->Tim17ClockSelection);
 800d060:	4b0e      	ldr	r3, [pc, #56]	@ (800d09c <HAL_RCCEx_PeriphCLKConfig+0x434>)
 800d062:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800d064:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
 800d068:	687b      	ldr	r3, [r7, #4]
 800d06a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800d06c:	490b      	ldr	r1, [pc, #44]	@ (800d09c <HAL_RCCEx_PeriphCLKConfig+0x434>)
 800d06e:	4313      	orrs	r3, r2
 800d070:	630b      	str	r3, [r1, #48]	@ 0x30

#endif /* STM32F302xE || STM32F303xE || STM32F398xx */  

#if defined(STM32F303xE) || defined(STM32F398xx)
  /*------------------------------ TIM20 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM20) == RCC_PERIPHCLK_TIM20)
 800d072:	687b      	ldr	r3, [r7, #4]
 800d074:	681b      	ldr	r3, [r3, #0]
 800d076:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800d07a:	2b00      	cmp	r3, #0
 800d07c:	d008      	beq.n	800d090 <HAL_RCCEx_PeriphCLKConfig+0x428>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM20CLKSOURCE(PeriphClkInit->Tim20ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM20_CONFIG(PeriphClkInit->Tim20ClockSelection);
 800d07e:	4b07      	ldr	r3, [pc, #28]	@ (800d09c <HAL_RCCEx_PeriphCLKConfig+0x434>)
 800d080:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800d082:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
 800d086:	687b      	ldr	r3, [r7, #4]
 800d088:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d08a:	4904      	ldr	r1, [pc, #16]	@ (800d09c <HAL_RCCEx_PeriphCLKConfig+0x434>)
 800d08c:	4313      	orrs	r3, r2
 800d08e:	630b      	str	r3, [r1, #48]	@ 0x30
  }
#endif /* STM32F303xE || STM32F398xx */  

  
  return HAL_OK;
 800d090:	2300      	movs	r3, #0
}
 800d092:	4618      	mov	r0, r3
 800d094:	3748      	adds	r7, #72	@ 0x48
 800d096:	46bd      	mov	sp, r7
 800d098:	bd80      	pop	{r7, pc}
 800d09a:	bf00      	nop
 800d09c:	40021000 	.word	0x40021000

0800d0a0 <memset>:
 800d0a0:	4402      	add	r2, r0
 800d0a2:	4603      	mov	r3, r0
 800d0a4:	4293      	cmp	r3, r2
 800d0a6:	d100      	bne.n	800d0aa <memset+0xa>
 800d0a8:	4770      	bx	lr
 800d0aa:	f803 1b01 	strb.w	r1, [r3], #1
 800d0ae:	e7f9      	b.n	800d0a4 <memset+0x4>

0800d0b0 <__libc_init_array>:
 800d0b0:	b570      	push	{r4, r5, r6, lr}
 800d0b2:	4d0d      	ldr	r5, [pc, #52]	@ (800d0e8 <__libc_init_array+0x38>)
 800d0b4:	4c0d      	ldr	r4, [pc, #52]	@ (800d0ec <__libc_init_array+0x3c>)
 800d0b6:	1b64      	subs	r4, r4, r5
 800d0b8:	10a4      	asrs	r4, r4, #2
 800d0ba:	2600      	movs	r6, #0
 800d0bc:	42a6      	cmp	r6, r4
 800d0be:	d109      	bne.n	800d0d4 <__libc_init_array+0x24>
 800d0c0:	4d0b      	ldr	r5, [pc, #44]	@ (800d0f0 <__libc_init_array+0x40>)
 800d0c2:	4c0c      	ldr	r4, [pc, #48]	@ (800d0f4 <__libc_init_array+0x44>)
 800d0c4:	f000 f818 	bl	800d0f8 <_init>
 800d0c8:	1b64      	subs	r4, r4, r5
 800d0ca:	10a4      	asrs	r4, r4, #2
 800d0cc:	2600      	movs	r6, #0
 800d0ce:	42a6      	cmp	r6, r4
 800d0d0:	d105      	bne.n	800d0de <__libc_init_array+0x2e>
 800d0d2:	bd70      	pop	{r4, r5, r6, pc}
 800d0d4:	f855 3b04 	ldr.w	r3, [r5], #4
 800d0d8:	4798      	blx	r3
 800d0da:	3601      	adds	r6, #1
 800d0dc:	e7ee      	b.n	800d0bc <__libc_init_array+0xc>
 800d0de:	f855 3b04 	ldr.w	r3, [r5], #4
 800d0e2:	4798      	blx	r3
 800d0e4:	3601      	adds	r6, #1
 800d0e6:	e7f2      	b.n	800d0ce <__libc_init_array+0x1e>
 800d0e8:	0800d16c 	.word	0x0800d16c
 800d0ec:	0800d16c 	.word	0x0800d16c
 800d0f0:	0800d16c 	.word	0x0800d16c
 800d0f4:	0800d170 	.word	0x0800d170

0800d0f8 <_init>:
 800d0f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d0fa:	bf00      	nop
 800d0fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d0fe:	bc08      	pop	{r3}
 800d100:	469e      	mov	lr, r3
 800d102:	4770      	bx	lr

0800d104 <_fini>:
 800d104:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d106:	bf00      	nop
 800d108:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d10a:	bc08      	pop	{r3}
 800d10c:	469e      	mov	lr, r3
 800d10e:	4770      	bx	lr
